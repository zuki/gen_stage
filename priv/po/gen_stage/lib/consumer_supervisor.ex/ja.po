msgid ""
msgstr ""
"Project-Id-Version: \n"
"PO-Revision-Date: 2017-03-09 10:34+0900\n"
"Last-Translator: Keiji Suzuki <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"POT-Creation-Date: \n"
"X-Generator: Poedit 1.8.12\n"

#. TRANSLATORS: @callback init/1
#: lib/consumer_supervisor.ex:72
msgid ""
"Callback invoked to start the supervisor and during hot code upgrades.\n"
"\n"
"## Options\n"
"\n"
"  * `:strategy` - the restart strategy option. Only `:one_for_one`\n"
"    is supported by consumer supervisors.\n"
"\n"
"  * `:max_restarts` - the maximum amount of restarts allowed in\n"
"    a time frame. Defaults to 3 times.\n"
"\n"
"  * `:max_seconds` - the time frame in which `:max_restarts` applies\n"
"    in seconds. Defaults to 5 seconds.\n"
"\n"
"  * `:max_dynamic` - the maximum number of children started under the\n"
"    supervisor via `start_child/2`. Defaults to infinity children.\n"
"\n"
"  * `:subscribe_to` - a list of producers to subscribe to. Each element\n"
"    represents the producer or a tuple with the producer and the "
"subscription\n"
"    options. e.g. `[Producer]` or `[{Producer, max_demand: 10, min_demand: "
"20}]`\n"
msgstr ""
"スーパーバイザを起動するため、また、ホットコードアップグレード中に\n"
"起動されるコールバックです。\n"
"\n"
"## オプション\n"
"\n"
"  * `:strategy` - 再起動戦略オプションです。消費者スーパーバイザでは\n"
"    `:one_for_one`だけがサポートされています。\n"
"\n"
"  * `:max_restarts` - ある時間間隔の中で許される再起動の最大回数。\n"
"    デフォルトは3回です。\n"
"\n"
"  * `:max_seconds` - `:max_restarts`に適用される秒単位の時間間隔です。\n"
"    デフォルトは5秒です。\n"
"\n"
"  * `:max_dynamic` - 監視下で`start_child/2`により起動できる子プロセスの\n"
"    最大数です。デフォルトは無限です。\n"
"\n"
"  * `:subscribe_to` - 購読する生産者のリストです。リストの各要素は生産"
"者、\n"
"    または生産者と購読オプションからなるタプルのいずれかです。たとえば、\n"
"    `[Producer]`または`[{Producer, max_demand: 10, min_demand: 20}]`。\n"

#. TRANSLATORS: @type options
#: lib/consumer_supervisor.ex:64
msgid "Options used by the `start*` functions"
msgstr "`start*`関数で使われるオプション"

#. TRANSLATORS: def ConsumerSupervisor.count_children(supervisor)
#: lib/consumer_supervisor.ex:213
msgid ""
"Returns a map containing count values for the supervisor.\n"
"\n"
"The map contains the following keys:\n"
"\n"
"  * `:specs` - always 1 as consumer supervisors have a single "
"specification\n"
"\n"
"  * `:active` - the count of all actively running child processes managed "
"by\n"
"    this supervisor\n"
"\n"
"  * `:supervisors` - the count of all supervisors whether or not the "
"child\n"
"    process is still alive\n"
"\n"
"  * `:workers` - the count of all workers, whether or not the child "
"process\n"
"    is still alive\n"
"\n"
msgstr ""
"スーパーバイザのカウント値を含むマップを返します。\n"
"\n"
"マップは次のキーを含みます。\n"
"\n"
"  * `:specs` - 常に1です。消費者スーパーバイザは仕様を1つしか持たないからで"
"す。\n"
"\n"
"  * `:active` - このスーパーバイザに管理されている稼働中のすべての子プロセ"
"スの数\n"
"\n"
"  * `:supervisors` - すべてのスーパーバイザの数。子プロセスが未だ生きている"
"か否かは\n"
"    問わない。\n"
"\n"
"  * `:workers` - すべてのワーカーの数。子プロセスが未だ生きているか否かは\n"
"    問わない。\n"
"\n"

#. TRANSLATORS: def ConsumerSupervisor.start_link(mod, args, opts \\ [])
#: lib/consumer_supervisor.ex:133
msgid ""
"Starts a consumer supervisor module with the given `arg`.\n"
"\n"
"To start the supervisor, the `init/1` callback will be invoked in the "
"given\n"
"module, with `arg` passed to it. The `init/1` callback must return a\n"
"supervision specification which can be created with the help of the\n"
"`Supervisor.Spec` module.\n"
"\n"
"If the `init/1` callback returns `:ignore`, this function returns\n"
"`:ignore` as well and the supervisor terminates with reason `:normal`.\n"
"If it fails or returns an incorrect value, this function returns\n"
"`{:error, term}` where `term` is a term with information about the\n"
"error, and the supervisor terminates with reason `term`.\n"
"\n"
"The `:name` option can also be given in order to register a supervisor\n"
"name, the supported values are described under the `Name Registration`\n"
"section in the `GenServer` module docs.\n"
msgstr ""
"指定した`arg`で消費者スーパーバイザモジュールを起動します。\n"
"\n"
"スーパーバイザを起動するために、指定したモジュールの`init/1`コールバック"
"に\n"
"`arg`が渡されて呼び出されます。`init/1`コールバックは、`Supervisor.Spec`\n"
"モジュールの助けを借りて作成することができるスーパーバイザ仕様を返さなけれ"
"ば\n"
"なりません。\n"
"\n"
"`init/1`コールバックが`:ignore`を返した場合、この関数は`:ignore`を返し、\n"
"スーパーバイザは理由`:normal`で終了します。`init/1`コールバックが失敗し"
"た、\n"
"または、不正な値を返した場合、この関数は`{:error, term}`を返します。ここ"
"で\n"
"`term`はエラーに関する情報を持つ項です。そして、スーパーバイザは理由\n"
"`term`で終了します。\n"
"\n"
"`:name`オプションを使って、スーパーバイザの名前を登録することもできます。\n"
"サポートされている値は、`GenServer`モジュールのドキュメントの「名前の登録」"
"に\n"
"記載されています。\n"

#. TRANSLATORS: def ConsumerSupervisor.start_link(children, options)
#: lib/consumer_supervisor.ex:108
msgid ""
"Starts a supervisor with the given children.\n"
"\n"
"A strategy is required to be given as an option. Furthermore,\n"
"the `:max_restarts`, `:max_seconds`, `:max_dynamic` and `:subscribe_to`\n"
"values can be configured as described in the documentation for the\n"
"`c:init/1` callback.\n"
"\n"
"The options can also be used to register a supervisor name.\n"
"The supported values are described under the `Name Registration`\n"
"section in the `GenServer` module docs.\n"
"\n"
"Note that the consumer supervisor is linked to the parent process\n"
"and will exit not only on crashes but also if the parent process\n"
"exits with `:normal` reason.\n"
msgstr ""
"指定した子プロセスを持つスーパーバイザを起動します。\n"
"\n"
"戦略をオプションで指定する必要があります。さらに、`c:init/1`コールバック"
"の\n"
"ドキュメントに記載されているように`:max_restarts`、`:max_seconds`、\n"
"`:max_dynamic`、`:subscribe_to`の値をオプションで構成することができます。\n"
"\n"
"オプションを使って、スーパーバイザの名前を登録することもできます。サポー"
"ト\n"
"されている値は、`GenServer`モジュールのドキュメントの「名前の登録」に\n"
"記載されています。\n"
"\n"
"消費者スーパーバイザは親プロセスにリンクされており、親プロセスがクラッシュ"
"した\n"
"場合だけでなく、`;normal`理由で終了した場合も、終了することに注意してくださ"
"い。\n"

#. TRANSLATORS: Elixir.ConsumerSupervisor Summary
#: lib/consumer_supervisor.ex:2
msgid ""
"A supervisor that starts children as events flow in.\n"
"\n"
"A `ConsumerSupervisor` can be used as the consumer in a `GenStage` "
"pipeline.\n"
"A new child process will be started per event, where the event is "
"appended\n"
"to the arguments in the child specification.\n"
"\n"
"A `ConsumerSupervisor` can be attached to a producer by returning\n"
"`:subscribe_to` from `init/1` or explicitly with `GenStage."
"sync_subscribe/3`\n"
"and `GenStage.async_subscribe/2`.\n"
"\n"
"Once subscribed, the supervisor will ask the producer for `max_demand` "
"events\n"
"and start child processes as events arrive. As child processes terminate, "
"the\n"
"supervisor will accumulate demand and request more events once "
"`min_demand`\n"
"is reached. This allows the `ConsumerSupervisor` to work similar to a "
"pool,\n"
"except a child process is started per event. The minimum amount of "
"concurrent\n"
"children per producer is specified by `min_demand` and the `maximum` is "
"given\n"
"by `max_demand`.\n"
"\n"
"## Example\n"
"\n"
"Let's define a GenStage consumer as a `ConsumerSupervisor` that "
"subscribes\n"
"to a producer named `Producer` and starts a new process for each event\n"
"received from the producer. Each new process will be started by calling\n"
"`Printer.start_link/1`, which simply starts a task that will print the\n"
"incoming event to the terminal.\n"
"\n"
"    defmodule Consumer do\n"
"      use ConsumerSupervisor\n"
"\n"
"      def start_link() do\n"
"        children = [\n"
"          worker(Printer, [], restart: :temporary)\n"
"        ]\n"
"\n"
"        ConsumerSupervisor.start_link(children, strategy: :one_for_one,\n"
"                                                subscribe_to: [{Producer, "
"max_demand: 50}])\n"
"      end\n"
"    end\n"
"\n"
"Then on the printer module:\n"
"\n"
"    defmodule Printer do\n"
"      def start_link(event) do\n"
"        Task.start_link(fn ->\n"
"          IO.inspect {self(), event}\n"
"        end)\n"
"      end\n"
"    end\n"
"\n"
"Similar to `Supervisor`, `ConsumerSupervisor` also provides "
"`start_link/3`,\n"
"which allows developers to start a supervisor with the help of a callback\n"
"module.\n"
"\n"
"## Name Registration\n"
"\n"
"A supervisor is bound to the same name registration rules as a "
"`GenServer`.\n"
"Read more about it in the `GenServer` docs.\n"
msgstr ""
"イベントを流す子プロセスを起動するスーパーバイザです。\n"
"\n"
"`ConsumerSupervisor`は`GenStage`パイプラインにおいて消費者として\n"
"使用することができます。新たな子プロセスをイベントごとに起動します。ここ"
"で\n"
"イベントは子プロセスの仕様における引数に追加されます。\n"
"\n"
"`ConsumerSupervisor`は`init/1`から`:subscribe_to`を返すことで、または、\n"
"`GenStage.sync_subscribe/3`や`GenStage.async_subscribe/2`で明示的に\n"
"生産者を購読することができます。\n"
"\n"
"購読をすると、スーパーバイザは生産者に`max_demand`個のイベントを要求し、\n"
"イベントが到着すると子プロセスを起動します。子プロセスが終了すると、\n"
"スーパーバイザは要求を蓄積し、`min_demand`個に達するとさらなるイベントを\n"
"リクエストします。これにより、子プロセスがイベントごとに起動されることを\n"
"除いて、`ConsumerSupervisor`はプールのように作動することができます。\n"
"生産者あたりの並行子プロセスの最小数は`min_demand`で、最大数は\n"
"`max_demand`で指定します。\n"
"\n"
"## 例\n"
"\n"
"`Producer`という名前の生産者を購読し、生産者から受け取るイベントごとに\n"
"子プロセスを起動するGenStage消費者を`ConsumerSupervisor`として定義\n"
"しましょう。各新プロセスは`Printer.start_link/1`を呼び出すことにより起動さ"
"れます。\n"
"これは単に受け取ったイベントを端末に出力するタスクを起動するだけです。\n"
"\n"
"    defmodule Consumer do\n"
"      use ConsumerSupervisor\n"
"\n"
"      def start_link() do\n"
"        children = [\n"
"          worker(Printer, [], restart: :temporary)\n"
"        ]\n"
"\n"
"        ConsumerSupervisor.start_link(children, strategy: :one_for_one,\n"
"                                                subscribe_to: [{Producer, "
"max_demand: 50}])\n"
"      end\n"
"    end\n"
"\n"
"次はプリンタモジュールです。\n"
"\n"
"    defmodule Printer do\n"
"      def start_link(event) do\n"
"        Task.start_link(fn ->\n"
"          IO.inspect {self(), event}\n"
"        end)\n"
"      end\n"
"    end\n"
"\n"
"`Supervisor`同様、`ConsumerSupervisor`もコールバックモジュールの助けを借り"
"て\n"
"スーパーバイザを起動できる`start_link/3`を提供しています。\n"
"\n"
"## 名前の登録\n"
"\n"
"スーパーバイザは`GenServer`と同じ名前登録規則に従います。詳細は`GenServer`"
"の\n"
"ドキュメントを参照してください。\n"

#. TRANSLATORS: def ConsumerSupervisor.start_child(supervisor, args)
#: lib/consumer_supervisor.ex:156
msgid ""
"Starts a child in the consumer supervisor.\n"
"\n"
"The child process will be started by appending the given list of\n"
"`args` to the existing function arguments in the child specification.\n"
"\n"
"If the child process starts, function returns `{:ok, child}` or\n"
"`{:ok, child, info}`, the pid is added to the supervisor and the\n"
"function returns the same value.\n"
"\n"
"If the child process starts, function returns ignore, an error tuple\n"
"or an erroneous value, or if it fails, the child is discarded and\n"
"`:ignore` or `{:error, error}` where `error` is a term containing\n"
"information about the error is returned.\n"
msgstr ""
"消費者スーパーバイザの子プロセスを起動します。\n"
"\n"
"子プロセスは、子プロセス仕様に書かれている既存の関数引数に、指定した\n"
"引数のリスト`args`を追加して起動されます。\n"
"\n"
"子プロセスが起動して、関数が`{:ok, child}`または`{:ok, child, info}`を返し"
"た\n"
"場合、pidはスーパーバイザに追加され、この関数は同じ値を返します。\n"
"\n"
"子プロセスが起動して、関数が`:ignore`、エラータプル、エラー値のいずれかを返"
"した、\n"
"または関数が失敗した場合、子プロセスは破棄され、`:ignore`または`{:error, "
"error}`を\n"
"返します。ここで、`error`はエラーに関する情報を含む項です。\n"

#. TRANSLATORS: def ConsumerSupervisor.terminate_child(supervisor, pid)
#: lib/consumer_supervisor.ex:176
msgid ""
"Terminates the given child pid.\n"
"\n"
"If successful, the function returns `:ok`. If there is no\n"
"such pid, the function returns `{:error, :not_found}`.\n"
msgstr ""
"指定したpidの子プロセスを終了させます。\n"
"\n"
"成功した場合、この関数は`:ok`を返します。指定したpidが\n"
"存在しない場合、この関数は`{:error, :not_found}`を返します。\n"

#. TRANSLATORS: def ConsumerSupervisor.which_children(supervisor)
#: lib/consumer_supervisor.ex:187
msgid ""
"Returns a list with information about all children.\n"
"\n"
"Note that calling this function when supervising a large number\n"
"of children under low memory conditions can cause an out of memory\n"
"exception.\n"
"\n"
"This function returns a list of tuples containing:\n"
"\n"
"  * `id` - as defined in the child specification but is always\n"
"    set to `:undefined` for consumer supervisors\n"
"\n"
"  * `child` - the pid of the corresponding child process or the\n"
"    atom `:restarting` if the process is about to be restarted\n"
"\n"
"  * `type` - `:worker` or `:supervisor` as defined in the child\n"
"    specification\n"
"\n"
"  * `modules` - as defined in the child specification\n"
msgstr ""
"すべての子プロセスに関する情報を持つリストを返します。\n"
"\n"
"メモリの少ない状況で大量の子プロセスを監視している場合にこの関数を\n"
"呼ぶと、メモリ不足例外を引き起こす可能性があることに注意してください。\n"
"\n"
"この関数は次の要素を含むタプルのリストを返します。\n"
"\n"
"  * `id` - 子プロセス仕様に定義されていますが、消費者スーパーバイザでは\n"
"    常に`:undefined`が設定されています。\n"
"\n"
"  * `child` - 対応する子プロセスのpid、または、プロセスが再起動中の場合は\n"
"    `:restarting`です。\n"
"\n"
"  * `type` - 子プロセス仕様で定義されている`:worker`または`:supervisor`で"
"す。\n"
"\n"
"  * `modules` - 子プロセス仕様で定義されているとおり\n"
