#. TRANSLATORS: @callback init/1
#: lib/consumer_supervisor.ex:72 
msgid ""
"Callback invoked to start the supervisor and during hot code upgrades.\n"
"\n"
"## Options\n"
"\n"
"  * `:strategy` - the restart strategy option. Only `:one_for_one`\n"
"    is supported by consumer supervisors.\n"
"\n"
"  * `:max_restarts` - the maximum amount of restarts allowed in\n"
"    a time frame. Defaults to 3 times.\n"
"\n"
"  * `:max_seconds` - the time frame in which `:max_restarts` applies\n"
"    in seconds. Defaults to 5 seconds.\n"
"\n"
"  * `:max_dynamic` - the maximum number of children started under the\n"
"    supervisor via `start_child/2`. Defaults to infinity children.\n"
"\n"
"  * `:subscribe_to` - a list of producers to subscribe to. Each element\n"
"    represents the producer or a tuple with the producer and the subscription\n"
"    options. e.g. `[Producer]` or `[{Producer, max_demand: 10, min_demand: 20}]`\n"
msgstr ""
#. TRANSLATORS: @type options
#: lib/consumer_supervisor.ex:64 
msgid ""
"Options used by the `start*` functions"
msgstr ""
#. TRANSLATORS: def ConsumerSupervisor.count_children(supervisor)
#: lib/consumer_supervisor.ex:213 
msgid ""
"Returns a map containing count values for the supervisor.\n"
"\n"
"The map contains the following keys:\n"
"\n"
"  * `:specs` - always 1 as consumer supervisors have a single specification\n"
"\n"
"  * `:active` - the count of all actively running child processes managed by\n"
"    this supervisor\n"
"\n"
"  * `:supervisors` - the count of all supervisors whether or not the child\n"
"    process is still alive\n"
"\n"
"  * `:workers` - the count of all workers, whether or not the child process\n"
"    is still alive\n"
"\n"
msgstr ""
#. TRANSLATORS: def ConsumerSupervisor.start_link(mod, args, opts \\ [])
#: lib/consumer_supervisor.ex:133 
msgid ""
"Starts a consumer supervisor module with the given `arg`.\n"
"\n"
"To start the supervisor, the `init/1` callback will be invoked in the given\n"
"module, with `arg` passed to it. The `init/1` callback must return a\n"
"supervision specification which can be created with the help of the\n"
"`Supervisor.Spec` module.\n"
"\n"
"If the `init/1` callback returns `:ignore`, this function returns\n"
"`:ignore` as well and the supervisor terminates with reason `:normal`.\n"
"If it fails or returns an incorrect value, this function returns\n"
"`{:error, term}` where `term` is a term with information about the\n"
"error, and the supervisor terminates with reason `term`.\n"
"\n"
"The `:name` option can also be given in order to register a supervisor\n"
"name, the supported values are described under the `Name Registration`\n"
"section in the `GenServer` module docs.\n"
msgstr ""
#. TRANSLATORS: def ConsumerSupervisor.start_link(children, options)
#: lib/consumer_supervisor.ex:108 
msgid ""
"Starts a supervisor with the given children.\n"
"\n"
"A strategy is required to be given as an option. Furthermore,\n"
"the `:max_restarts`, `:max_seconds`, `:max_dynamic` and `:subscribe_to`\n"
"values can be configured as described in the documentation for the\n"
"`c:init/1` callback.\n"
"\n"
"The options can also be used to register a supervisor name.\n"
"The supported values are described under the `Name Registration`\n"
"section in the `GenServer` module docs.\n"
"\n"
"Note that the consumer supervisor is linked to the parent process\n"
"and will exit not only on crashes but also if the parent process\n"
"exits with `:normal` reason.\n"
msgstr ""
#. TRANSLATORS: Elixir.ConsumerSupervisor Summary
#: lib/consumer_supervisor.ex:2 
msgid ""
"A supervisor that starts children as events flow in.\n"
"\n"
"A `ConsumerSupervisor` can be used as the consumer in a `GenStage` pipeline.\n"
"A new child process will be started per event, where the event is appended\n"
"to the arguments in the child specification.\n"
"\n"
"A `ConsumerSupervisor` can be attached to a producer by returning\n"
"`:subscribe_to` from `init/1` or explicitly with `GenStage.sync_subscribe/3`\n"
"and `GenStage.async_subscribe/2`.\n"
"\n"
"Once subscribed, the supervisor will ask the producer for `max_demand` events\n"
"and start child processes as events arrive. As child processes terminate, the\n"
"supervisor will accumulate demand and request more events once `min_demand`\n"
"is reached. This allows the `ConsumerSupervisor` to work similar to a pool,\n"
"except a child process is started per event. The minimum amount of concurrent\n"
"children per producer is specified by `min_demand` and the `maximum` is given\n"
"by `max_demand`.\n"
"\n"
"## Example\n"
"\n"
"Let's define a GenStage consumer as a `ConsumerSupervisor` that subscribes\n"
"to a producer named `Producer` and starts a new process for each event\n"
"received from the producer. Each new process will be started by calling\n"
"`Printer.start_link/1`, which simply starts a task that will print the\n"
"incoming event to the terminal.\n"
"\n"
"    defmodule Consumer do\n"
"      use ConsumerSupervisor\n"
"\n"
"      def start_link() do\n"
"        children = [\n"
"          worker(Printer, [], restart: :temporary)\n"
"        ]\n"
"\n"
"        ConsumerSupervisor.start_link(children, strategy: :one_for_one,\n"
"                                                subscribe_to: [{Producer, max_demand: 50}])\n"
"      end\n"
"    end\n"
"\n"
"Then on the printer module:\n"
"\n"
"    defmodule Printer do\n"
"      def start_link(event) do\n"
"        Task.start_link(fn ->\n"
"          IO.inspect {self(), event}\n"
"        end)\n"
"      end\n"
"    end\n"
"\n"
"Similar to `Supervisor`, `ConsumerSupervisor` also provides `start_link/3`,\n"
"which allows developers to start a supervisor with the help of a callback\n"
"module.\n"
"\n"
"## Name Registration\n"
"\n"
"A supervisor is bound to the same name registration rules as a `GenServer`.\n"
"Read more about it in the `GenServer` docs.\n"
msgstr ""
#. TRANSLATORS: def ConsumerSupervisor.start_child(supervisor, args)
#: lib/consumer_supervisor.ex:156 
msgid ""
"Starts a child in the consumer supervisor.\n"
"\n"
"The child process will be started by appending the given list of\n"
"`args` to the existing function arguments in the child specification.\n"
"\n"
"If the child process starts, function returns `{:ok, child}` or\n"
"`{:ok, child, info}`, the pid is added to the supervisor and the\n"
"function returns the same value.\n"
"\n"
"If the child process starts, function returns ignore, an error tuple\n"
"or an erroneous value, or if it fails, the child is discarded and\n"
"`:ignore` or `{:error, error}` where `error` is a term containing\n"
"information about the error is returned.\n"
msgstr ""
#. TRANSLATORS: def ConsumerSupervisor.terminate_child(supervisor, pid)
#: lib/consumer_supervisor.ex:176 
msgid ""
"Terminates the given child pid.\n"
"\n"
"If successful, the function returns `:ok`. If there is no\n"
"such pid, the function returns `{:error, :not_found}`.\n"
msgstr ""
#. TRANSLATORS: def ConsumerSupervisor.which_children(supervisor)
#: lib/consumer_supervisor.ex:187 
msgid ""
"Returns a list with information about all children.\n"
"\n"
"Note that calling this function when supervising a large number\n"
"of children under low memory conditions can cause an out of memory\n"
"exception.\n"
"\n"
"This function returns a list of tuples containing:\n"
"\n"
"  * `id` - as defined in the child specification but is always\n"
"    set to `:undefined` for consumer supervisors\n"
"\n"
"  * `child` - the pid of the corresponding child process or the\n"
"    atom `:restarting` if the process is about to be restarted\n"
"\n"
"  * `type` - `:worker` or `:supervisor` as defined in the child\n"
"    specification\n"
"\n"
"  * `modules` - as defined in the child specification\n"
msgstr ""
