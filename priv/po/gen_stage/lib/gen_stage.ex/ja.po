msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2017-03-09 16:05+0900\n"
"Last-Translator: Keiji Suzuki <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 1.8.12\n"

#. TRANSLATORS: @callback handle_cast/2
#: lib/gen_stage.ex:898
msgid ""
"Invoked to handle asynchronous `cast/2` messages.\n"
"\n"
"`request` is the request message sent by a `cast/2` and `state` is the "
"current\n"
"state of the `GenStage`.\n"
"\n"
"Returning `{:noreply, [event], new_state}` dispatches the events and "
"continues\n"
"the loop with new state `new_state`.\n"
"\n"
"Returning `{:noreply, [event], new_state, :hibernate}` is similar to\n"
"`{:noreply, new_state}` except the process is hibernated before continuing "
"the\n"
"loop.\n"
"\n"
"Returning `{:stop, reason, new_state}` stops the loop and `terminate/2` is\n"
"called with the reason `reason` and state `new_state`. The process exits "
"with\n"
"reason `reason`.\n"
"\n"
"If this callback is not implemented, the default implementation by\n"
"`use GenStage` will return `{:stop, {:bad_cast, request}, state}`.\n"
msgstr ""
"`cast/2`メッセージを非同期的に処理するために呼び出されます。\n"
"\n"
"`request`は`cast/2`により送信されたリクエストメッセージであり、`state`は\n"
"`GenStage`の現在の状態です。\n"
"\n"
"`{:noreply, [event], new_state}`を返すと、イベントをディスパッチし、新たな\n"
"状態`new_state`でループを継続します。\n"
"\n"
"`{:noreply, [event], new_state, :hibernate}`はループを継続する前にプロセス"
"が\n"
"ハイバネーションされることを除いて`{:noreply, new_state}`と同じです。\n"
"\n"
"`{:stop, reason, new_state}`を返すと、ループを停止し、理由`reason`と\n"
"状態`new_state`を引数に`terminate/2`が呼び出されます。プロセスは\n"
"理由`reason`で終了します。\n"
"\n"
"このコールバックが実装されていない場合、`use GenStage`によるデフォルトの\n"
"実装が`{:stop, {:bad_cast, request}, state}`を返します。\n"

#. TRANSLATORS: def GenStage.sync_notify(stage, msg, timeout \\ 5000)
#: lib/gen_stage.ex:1079
msgid ""
"Asks the producer to send a notification to all consumers synchronously.\n"
"\n"
"This call is synchronous and will return after the producer has either\n"
"sent the notification to all consumers or placed it in a buffer. In\n"
"other words, it guarantees the producer has handled the message but not\n"
"that the consumers have received it.\n"
"\n"
"The given message will be delivered in the format\n"
"`{{producer_pid, subscription_tag}, msg}`, where `msg` is the message\n"
"given below. `subscription_tag` is the subscription tag passed to the\n"
"consumer's `c:handle_subscribe/4` callback in the `to_or_from` tuple.\n"
"Consumers that wish to verify the `subscription_tag` in their\n"
"`c:handle_info/2` implementation should store such subscription tag in\n"
"their state.\n"
"\n"
"This function will return `:ok` as long as the notification request is\n"
"sent. It may return `{:error, :not_a_producer}` in case the stage is not\n"
"a producer.\n"
msgstr ""
"すべての消費者に同期的に通知を送信するよう生産者に依頼します。\n"
"\n"
"この関数は同期的であり、生産者がすべての消費者に通知を送信した、または\n"
"通知をバッファに置いた後に返ります。言い換えれば、生産者がメッセージを\n"
"処理したことは保証されますが、消費者がそれを受信したことは保証されません。\n"
"\n"
"指定メッセージは`{{producer_pid, subscription_tag}, msg}`の形式で\n"
"配信されます。ここで、`msg`は指定したメッセージです。`subscription_tag`は\n"
"`to_or_from`タプルの中で消費者の`c:handle_subscribe/4`コールバックに\n"
"渡される購読タグです。`c:handle_info/2`の実装において、`subscription_tag`を\n"
"検証したい消費者は購読タグを自分の状態に格納するべきです。\n"
"\n"
"この関数は通知リクエストが送信された限り`:ok`を返します。ステージが生産者で"
"は\n"
"ない場合は`{:error, :not_a_producer}`を返します。\n"

#. TRANSLATORS: @callback code_change/3
#: lib/gen_stage.ex:945
msgid "The same as `c:GenServer.code_change/3`.\n"
msgstr "`c:GenServer.code_change/3`と同じです。\n"

#. TRANSLATORS: def GenStage.async_subscribe(stage, opts)
#: lib/gen_stage.ex:1201
msgid ""
"Asks the consumer to subscribe to the given producer asynchronously.\n"
"\n"
"This call returns `:ok` regardless if the subscription\n"
"effectively happened or not. It is typically called from\n"
"a stage's `init/1` callback.\n"
"\n"
"## Options\n"
"\n"
"  * `:cancel` - `:permanent` (default) or `:temporary`. When permanent,\n"
"    the consumer exits when the producer cancels or exits. In case\n"
"    of exits, the same reason is used to exit the consumer. In case of\n"
"    cancellations, the reason is wrapped in a `:cancel` tuple.\n"
"  * `:min_demand` - the minimum demand for this subscription\n"
"  * `:max_demand` - the maximum demand for this subscription\n"
"\n"
"All other options are sent as is to the producer stage.\n"
msgstr ""
"消費者に指定の生産者を購読するよう非同期に要求します。\n"
"\n"
"この関数は、購読が有効になったのか否かにかかわらず、`:ok`を返します。\n"
"通常は、ステージの`init/1`コールバックから呼び出されます。\n"
"\n"
"## オプション\n"
"\n"
"  * `:cancel` - `:permanent` (デフォルト) または `:temporary`。\n"
"    :permanentの場合、生産者がキャンセルまたは終了した場合、\n"
"    消費者は終了します。終了の場合、消費者を終了させるために\n"
"    同じ理由が使用されます。キャンセルの場合、理由は`:cancel`タプルに\n"
"    包まれます。\n"
"  * `:min_demand` - この購読の最小の要求\n"
"  * `:max_demand` - この購読の最大の要求\n"
"\n"
"その他のすべてのオプションはそのまま生産者ステージに送信されます。\n"

#. TRANSLATORS: def GenStage.start(module, args, options \\ [])
#: lib/gen_stage.ex:1069
msgid ""
"Starts a `GenStage` process without links (outside of a supervision tree).\n"
"\n"
"See `start_link/3` for more information.\n"
msgstr ""
"リンクなしに`GenStage`プロセスを（監視ツリーの外で）起動します。\n"
"\n"
"詳細は`start_link/3`を参照してください。\n"

#. TRANSLATORS: @callback handle_subscribe/4
#: lib/gen_stage.ex:805
msgid ""
"Invoked when a consumer subscribes to a producer.\n"
"\n"
"This callback is invoked in both producers and consumers.\n"
"\n"
"For consumers, successful subscriptions must return `{:automatic, new_state}"
"`\n"
"or `{:manual, state}`. The default is to return `:automatic`, which means\n"
"the stage implementation will take care of automatically sending demand to\n"
"producers. `:manual` must be used when a special behaviour is desired\n"
"(for example, `ConsumerSupervisor` uses `:manual` demand) and demand must\n"
"be sent explicitly with `ask/2`. The manual subscription must be cancelled\n"
"when `handle_cancel/3` is called.\n"
"\n"
"For producers, successful subscriptions must always return\n"
"`{:automatic, new_state}`, the `:manual` mode is not supported.\n"
"\n"
"If this callback is not implemented, the default implementation by\n"
"`use GenStage` will return `{:automatic, state}`.\n"
msgstr ""
"消費者が生産者を購読した時に呼び出されます。\n"
"\n"
"このコールバックは生産者、消費者の双方から呼び出されます。\n"
"\n"
"消費者は、購読が成功した場合、`{:automatic, new_state}`または\n"
"`{:manual, state}`のいずれかを返さなければなりません。デフォルトは\n"
"`:automatic`を返すことで、ステージ実装が生産者への要求の送信を自動的に\n"
"面倒を見ることを意味します。`:manual`は特別なふるまいが望ましい場合に\n"
"使用されるべきです（たとえば、`ConsumerSupervisor`は`:manual`要求を\n"
"使用します）。この場合、要求は`ask/2`で明示的に送信する必要があります。\n"
"手動購読は`handle_cancel/3`が呼び出された時にキャンセルされなければなりませ"
"ん。\n"
"\n"
"生産者は、購読が成功した場合、常に`{:automatic, new_state}`を返さなければ\n"
"なりません。`:manual`モードはサポートされていません。\n"
"\n"
"このコールバックが実装されていない場合、`use GenStage`によるデフォルトの\n"
"実装が`{:automatic, state}`を返します。\n"

#. TRANSLATORS: def GenStage.async_resubscribe(stage, ref, reason, opts)
#: lib/gen_stage.ex:1224
msgid ""
"Cancels `ref` with `reason` and subscribe asynchronously in one step.\n"
"\n"
"See `async_subscribe/2` for examples and options.\n"
msgstr ""
"一回の処理で、`ref`を`reason`でキャンセルし、非同期的に購読します。\n"
"\n"
"例とオプションに関しては`async_subscribe/2`を参照してください。\n"

#. TRANSLATORS: def GenStage.stop(stage, reason \\ :normal, timeout \\ :infinity)
#: lib/gen_stage.ex:1373
msgid ""
"Stops the stage with the given `reason`.\n"
"\n"
"The `terminate/2` callback of the given `stage` will be invoked before\n"
"exiting. This function returns `:ok` if the server terminates with the\n"
"given reason; if it terminates with another reason, the call exits.\n"
"\n"
"This function keeps OTP semantics regarding error reporting.\n"
"If the reason is any other than `:normal`, `:shutdown` or\n"
"`{:shutdown, _}`, an error report is logged.\n"
msgstr ""
"ステージを指定した`reson`で停止します。\n"
"\n"
"終了する前に、指定した`stage`の`terminate/2`コールバックが呼び出されます。\n"
"この関数はサーバーが指定した理由で終了した場合、`:ok`を返します。別の理由で\n"
"終了した場合は、この関数は終了します。\n"
"\n"
"この関数はエラーレポートに関するOTPセマンティクスに従います。理由が`:"
"normal`、\n"
"`:shutdown`、`{:shutdown, _}`以外の場合、エラーレポートがログ出力されます。\n"

#. TRANSLATORS: def GenStage.start_link(module, args, options \\ [])
#: lib/gen_stage.ex:1022
msgid ""
"Starts a `GenStage` process linked to the current process.\n"
"\n"
"This is often used to start the `GenStage` as part of a supervision tree.\n"
"\n"
"Once the server is started, the `init/1` function of the given `module` is\n"
"called with `args` as its arguments to initialize the stage. To ensure a\n"
"synchronized start-up procedure, this function does not return until "
"`init/1`\n"
"has returned.\n"
"\n"
"Note that a `GenStage` started with `start_link/3` is linked to the\n"
"parent process and will exit in case of crashes from the parent. The "
"`GenStage`\n"
"will also exit due to the `:normal` reasons in case it is configured to "
"trap\n"
"exits in the `init/1` callback.\n"
"\n"
"## Options\n"
"\n"
"  * `:name` - used for name registration as described in the \"Name\n"
"    registration\" section of the module documentation\n"
"\n"
"  * `:timeout` - if present, the server is allowed to spend the given amount "
"of\n"
"    milliseconds initializing or it will be terminated and the start "
"function\n"
"    will return `{:error, :timeout}`\n"
"\n"
"  * `:debug` - if present, the corresponding function in the [`:sys`\n"
"    module](http://www.erlang.org/doc/man/sys.html) is invoked\n"
"\n"
"  * `:spawn_opt` - if present, its value is passed as options to the\n"
"    underlying process as in `Process.spawn/4`\n"
"\n"
"## Return values\n"
"\n"
"If the server is successfully created and initialized, this function "
"returns\n"
"`{:ok, pid}`, where `pid` is the pid of the server. If a process with the\n"
"specified server name already exists, this function returns\n"
"`{:error, {:already_started, pid}}` with the pid of that process.\n"
"\n"
"If the `init/1` callback fails with `reason`, this function returns\n"
"`{:error, reason}`. Otherwise, if it returns `{:stop, reason}`\n"
"or `:ignore`, the process is terminated and this function returns\n"
"`{:error, reason}` or `:ignore`, respectively.\n"
msgstr ""
"現在のプロセスにリンクされた`GenStage`プロセスを起動します。\n"
"\n"
"これは通常、`GenStage`を監視ツリー配下で起動するために使用されます。\n"
"\n"
"サーバーが起動されると、ステージを初期化するために指定した`module`の\n"
"`init/1`関数が`args`を引数として呼び出されます。同期的な起動処理を保証\n"
"するために、この関数は`init/1`が返るまで返りません。\n"
"\n"
"`start_link/3`により起動された`GenStage`は親プロセスとリンクされており、\n"
"親プロセスがクラッシュした場合は終了することに注意してください。\n"
"`GenStage`は、`init/1`コールバックで終了を捕捉するよう構成されている場合、\n"
"`:normal`理由でも終了します。\n"
"\n"
"## オプション\n"
"\n"
"  * `:name` - このモジュールのドキュメントの「名前の登録」セクションで\n"
"    説明されている名前の登録に使用されます。\n"
"\n"
"  * `:timeout` - 指定された場合、サーバーは指定したミリ秒だけ初期化に\n"
"    時間をとることができます。時間内に初期化が終了しない場合は、サーバーは\n"
"    終了し、この関数は`{:error, :timeout}`を返します。\n"
"\n"
"  * `:debug` - 指定された場合、[`:sys`モジュール](http://www.erlang.org/doc/"
"man/sys.html) is invoked\n"
"    の対応する関数が呼び出されます。\n"
"\n"
"  * `:spawn_opt` - 指定された場合、その値は`Process.spawn/4`と同様に基礎とな"
"る\n"
"    プロセスにオプションとして渡されます。\n"
"\n"
"## 返り値\n"
"\n"
"サーバーが作成され初期化が成功した場合、この関数は`{:ok, pid}`を返します。\n"
"ここで、`pid`はサーバーのpidです。指定したサーバー名を持つプロセスがすでに\n"
"存在した場合は、この関数は`{:error, {:already_started, pid}}`を返します。pid"
"は\n"
"そのプロセスのpidです。\n"
"\n"
"`init/1`コールバックが`reason`で失敗した場合、この関数は`{:error, reason}`"
"を\n"
"返します。コールバックが`{:stop, reason}`または`:ignore`を返した場合は、\n"
"プロセスは終了し、この関数は各々`{:error, reason}`または`:ignore`を返しま"
"す。\n"

#. TRANSLATORS: def GenStage.sync_subscribe(stage, opts, timeout \\ 5000)
#: lib/gen_stage.ex:1140
msgid ""
"Asks the consumer to subscribe to the given producer synchronously.\n"
"\n"
"This call is synchronous and will return after the called consumer\n"
"sends the subscribe message to the producer. It does not, however,\n"
"wait for the subscription confirmation. Therefore this function\n"
"will return before `handle_subscribe` is called in the consumer.\n"
"In other words, it guarantees the message was sent, but it does not\n"
"guarantee a subscription has effectively been established.\n"
"\n"
"This function will return `{:ok, ref}` as long as the subscription\n"
"message is sent. It may return `{:error, :not_a_consumer}` in case\n"
"the stage is not a consumer.\n"
"\n"
"## Options\n"
"\n"
"  * `:cancel` - `:permanent` (default) or `:temporary`. When permanent,\n"
"    the consumer exits when the producer cancels or exits. In case\n"
"    of exits, the same reason is used to exit the consumer. In case of\n"
"    cancellations, the reason is wrapped in a `:cancel` tuple.\n"
"  * `:min_demand` - the minimum demand for this subscription\n"
"  * `:max_demand` - the maximum demand for this subscription\n"
"\n"
"Any other option is sent to the producer stage. This may be used by\n"
"dispatchers for custom configuration. For example, if a producer uses\n"
"a `GenStage.BroadcastDispatcher`,  an optional `:selector` function\n"
"that receives an event and returns a boolean limits this subscription to\n"
"receiving only those events where the selector function returns a truthy\n"
"value:\n"
"\n"
"    GenStage.sync_subscribe(consumer,\n"
"      to: producer,\n"
"      selector: fn %{key: key} -> String.starts_with?(key, \"foo-\") end)\n"
"\n"
"All other options are sent as is to the producer stage.\n"
msgstr ""
"消費者に指定の生産者を購読するよう同期的に要求します。\n"
"\n"
"この関数は同期的であり、呼び出した消費者が生産者に購読メッセージを送信した\n"
"後に返ります。しかし、購読の確認は待ちません。そのため、この関数は消費者が\n"
"`handle_subscribe`を呼ぶ前に返ります。言い換えると、メッセージが送信された\n"
"ことは保証されますが、購読が正式に認められたことは保証されません。\n"
"\n"
"この関数は購読メッセージが送信された限りは`{:ok, ref}`を返します。ステージ"
"が\n"
"消費者でない場合は`{:error, :not_a_consumer}`を返します。\n"
"\n"
"## オプション\n"
"\n"
"  * `:cancel` - `:permanent` (デフォルト) または `:temporary`。\n"
"    :permanentの場合、生産者がキャンセルまたは終了した場合、\n"
"    消費者は終了します。終了の場合、消費者を終了させるために\n"
"    同じ理由が使用されます。キャンセルの場合、理由は`:cancel`タプルに\n"
"    包まれます。\n"
"  * `:min_demand` - この購読の最小の要求\n"
"  * `:max_demand` - この購読の最大の要求\n"
"\n"
"その他のすべてのオプションは生産者ステージに送信されます。独自に\n"
"構成することで、このオプションをディスパッチャで使用することもできます。\n"
"たとえば、生産者が`GenStage.BroadcastDispatcher`を使用している場合、\n"
"イベントを受け取りブール値を返す`:selector`関数をオプションに指定すると、\n"
"この選択関数がtruthy値を返すイベントだけを受信するようにこの購読を制限しま"
"す。\n"
"\n"
"    GenStage.sync_subscribe(consumer,\n"
"      to: producer,\n"
"      selector: fn %{key: key} -> String.starts_with?(key, \"foo-\") end)\n"
"\n"
"その他のすべてのオプションはそのまま生産者ステージに送信されます。\n"
"\n"

#. TRANSLATORS: def GenStage.cast(stage, request)
#: lib/gen_stage.ex:1314
msgid ""
"Sends an asynchronous request to the `stage`.\n"
"\n"
"This function always returns `:ok` regardless of whether\n"
"the destination `stage` (or node) exists. Therefore it\n"
"is unknown whether the destination `stage` successfully\n"
"handled the message.\n"
"\n"
"`handle_cast/2` will be called on the stage to handle\n"
"the request. In case the `stage` is on a node which is\n"
"not yet connected to the caller one, the call is going to\n"
"block until a connection happens.\n"
msgstr ""
"非同期リクエストを`stage`に送信します。\n"
"\n"
"この関数は送信先の`stage`（またはノード）が存在するか否かにかかわらず\n"
"常に`:ok`を返します。そのため、送信先の`stage`がメッセージを正しく\n"
"処理したか否かは分かりません。\n"
"\n"
"リクエストを処理するためにステージ上で`handle_cast/2`が呼び出されます。\n"
"`stage`が呼び出し元とまだ接続されていないノードにある場合は、接続される\n"
"まで呼び出しはブロックされます。\n"

#. TRANSLATORS: @callback handle_demand/2
#: lib/gen_stage.ex:793
msgid ""
"Invoked on :producer stages.\n"
"\n"
"Must always be explicitly implemented by `:producer` types.\n"
"It is invoked with the demand from consumers/dispatcher. The\n"
"producer must either store the demand or return the events requested.\n"
msgstr ""
":producerステージで呼び出されます。\n"
"\n"
"`:producer`タイプでは常に明示的に実装する必要があります。\n"
"消費者またはディスパッチャからの要求を引数に呼び出されます。生産者は\n"
"要求を格納するか、リクエストされたイベントを返すかのいずれかをしなければ\n"
"なりません。\n"

#. TRANSLATORS: Elixir.GenStage Summary
#: lib/gen_stage.ex:2
msgid ""
"Stages are data-exchange steps that send and/or receive data\n"
"from other stages.\n"
"\n"
"When a stage sends data, it acts as a producer. When it receives\n"
"data, it acts as a consumer. Stages may take both producer and\n"
"consumer roles at once.\n"
"\n"
"## Stage types\n"
"\n"
"Besides taking both producer and consumer roles, a stage may be\n"
"called \"source\" if it only produces items or called \"sink\" if it\n"
"only consumes items.\n"
"\n"
"For example, imagine the stages below where A sends data to B\n"
"that sends data to C:\n"
"\n"
"    [A] -> [B] -> [C]\n"
"\n"
"we conclude that:\n"
"\n"
"  * A is only a producer (and therefore a source)\n"
"  * B is both producer and consumer\n"
"  * C is only a consumer (and therefore a sink)\n"
"\n"
"As we will see in the upcoming Examples section, we must\n"
"specify the type of the stage when we implement each of them.\n"
"\n"
"To start the flow of events, we subscribe consumers to\n"
"producers. Once the communication channel between them is\n"
"established, consumers will ask the producers for events.\n"
"We typically say the consumer is sending demand upstream.\n"
"Once demand arrives, the producer will emit items, never\n"
"emitting more items than the consumer asked for. This provides\n"
"a back-pressure mechanism.\n"
"\n"
"A consumer may have multiple producers and a producer may have\n"
"multiple consumers. When a consumer asks for data, each producer\n"
"is handled separately, with its own demand. When a producer\n"
"receives demand and sends data to multiple consumers, the demand\n"
"is tracked and the events are sent by a dispatcher. This allows\n"
"producers to send data using different \"strategies\". See\n"
"`GenStage.Dispatcher` for more information.\n"
"\n"
"Many developers tend to create layers of stages, such as A, B and\n"
"C for achieving concurrency. However, that's a misuse of GenStage.\n"
"Processes in Elixir are the abstraction for achieving concurrency,\n"
"since the VM does all of the work of multiplexing those processes.\n"
"Instead, layers in GenStage must be created when there is a need\n"
"for back-pressure or to route the data in different ways.\n"
"\n"
"For example, if you need the data to go over multiple steps but\n"
"without a need for back-pressure or without a need to break the\n"
"data apart, do not design it as such:\n"
"\n"
"    [Producer] -> [Step 1] -> [Step 2] -> [Step 3]\n"
"\n"
"Instead it is better to design it as:\n"
"\n"
"                [Consumer]\n"
"               /\n"
"    [Producer]--[Consumer]\n"
"               \\\n"
"                [Consumer]\n"
"\n"
"Where Consumer are multiple processes that subscribe to the same\n"
"producer and run exactly the same code, with all of transformation\n"
"steps from above. The module `ConsumerSupervisor` that is included\n"
"as part of `GenStage` provides conveniences for the design above.\n"
"\n"
"## Example\n"
"\n"
"Let's define the simple pipeline below:\n"
"\n"
"    [A] -> [B] -> [C]\n"
"\n"
"where A is a producer that will emit items starting from 0,\n"
"B is a producer-consumer that will receive those items and\n"
"multiply them by a given number and C will receive those events\n"
"and print them to the terminal.\n"
"\n"
"Let's start with A. Since A is a producer, its main\n"
"responsibility is to receive demand and generate events.\n"
"Those events may be in memory or an external queue system.\n"
"For simplicity, let's implement a simple counter starting\n"
"from a given value of `counter` received on `init/1`:\n"
"\n"
"    defmodule A do\n"
"      use GenStage\n"
"\n"
"      def start_link(number) do\n"
"        GenStage.start_link(A, number)\n"
"      end\n"
"\n"
"      def init(counter) do\n"
"        {:producer, counter}\n"
"      end\n"
"\n"
"      def handle_demand(demand, counter) when demand > 0 do\n"
"        # If the counter is 3 and we ask for 2 items, we will\n"
"        # emit the items 3 and 4, and set the state to 5.\n"
"        events = Enum.to_list(counter..counter+demand-1)\n"
"        {:noreply, events, counter + demand}\n"
"      end\n"
"    end\n"
"\n"
"B is a producer-consumer. This means it does not explicitly\n"
"handle the demand because the demand is always forwarded to\n"
"its producer. Once A receives the demand from B, it will send\n"
"events to B which will be transformed by B as desired. In\n"
"our case, B will receive events and multiply them by a number\n"
"given on initialization and stored as the state:\n"
"\n"
"    defmodule B do\n"
"      use GenStage\n"
"\n"
"      def start_link(number) do\n"
"        GenStage.start_link(B, number)\n"
"      end\n"
"\n"
"      def init(number) do\n"
"        {:producer_consumer, number}\n"
"      end\n"
"\n"
"      def handle_events(events, _from, number) do\n"
"        events = Enum.map(events, & &1 * number)\n"
"        {:noreply, events, number}\n"
"      end\n"
"    end\n"
"\n"
"C will finally receive those events and print them every second\n"
"to the terminal:\n"
"\n"
"    defmodule C do\n"
"      use GenStage\n"
"\n"
"      def start_link() do\n"
"        GenStage.start_link(C, :ok)\n"
"      end\n"
"\n"
"      def init(:ok) do\n"
"        {:consumer, :the_state_does_not_matter}\n"
"      end\n"
"\n"
"      def handle_events(events, _from, state) do\n"
"        # Wait for a second.\n"
"        :timer.sleep(1000)\n"
"\n"
"        # Inspect the events.\n"
"        IO.inspect(events)\n"
"\n"
"        # We are a consumer, so we would never emit items.\n"
"        {:noreply, [], state}\n"
"      end\n"
"    end\n"
"\n"
"Now we can start and connect them:\n"
"\n"
"    {:ok, a} = A.start_link(0)  # starting from zero\n"
"    {:ok, b} = B.start_link(2)  # multiply by 2\n"
"    {:ok, c} = C.start_link()   # state does not matter\n"
"\n"
"    GenStage.sync_subscribe(c, to: b)\n"
"    GenStage.sync_subscribe(b, to: a)\n"
"\n"
"Notice we typically subscribe from bottom to top. Since A will\n"
"start producing items only when B connects to it, we want this\n"
"subscription to happen when the whole pipeline is ready. After\n"
"you subscribe all of them, demand will start flowing upstream and\n"
"events downstream.\n"
"\n"
"When implementing consumers, we often set the `:max_demand` and\n"
"`:min_demand` on subscription. The `:max_demand` specifies the\n"
"maximum amount of events that must be in flow while the `:min_demand`\n"
"specifies the minimum threshold to trigger for more demand. For\n"
"example, if `:max_demand` is 1000 and `:min_demand` is 500\n"
"(the default values), the consumer will ask for 1000 events initially\n"
"and ask for more only after it receives at least 500.\n"
"\n"
"In the example above, B is a `:producer_consumer` and therefore\n"
"acts as a buffer. Getting the proper demand values in B is\n"
"important: making the buffer too small may make the whole pipeline\n"
"slower, making the buffer too big may unnecessarily consume\n"
"memory.\n"
"\n"
"When such values are applied to the stages above, it is easy\n"
"to see the producer works in batches. The producer A ends-up\n"
"emitting batches of 50 items which will take approximately\n"
"50 seconds to be consumed by C, which will then request another\n"
"batch of 50 items.\n"
"\n"
"## `init` and `subscribe_to`\n"
"\n"
"In the example above, we have started the processes A, B and C\n"
"independently and subscribed them later on. But most often it is\n"
"simpler to subscribe a consumer to its producer on its `c:init/1`\n"
"callback. This way, if the consumer crashes, restarting the consumer\n"
"will automatically re-invoke its `c:init/1` callback and resubscribe\n"
"it to the supervisor.\n"
"\n"
"This approach works as long as the producer can be referenced when\n"
"the consumer starts--such as by name (for a named process) or by pid\n"
"for a running unnamed process.  For example, assuming the process\n"
"`A` and `B` are started as follows:\n"
"\n"
"    # Let's call the stage in module A as A\n"
"    GenStage.start_link(A, 0, name: A)\n"
"    # Let's call the stage in module B as B\n"
"    GenStage.start_link(B, 2, name: B)\n"
"    # No need to name consumers as they won't be subscribed to\n"
"    GenStage.start_link(C, :ok)\n"
"\n"
"We can now change the `c:init/1` callback for C to the following:\n"
"\n"
"    def init(:ok) do\n"
"      {:consumer, :the_state_does_not_matter, subscribe_to: [B]}\n"
"    end\n"
"\n"
"Or:\n"
"\n"
"    def init(:ok) do\n"
"      {:consumer, :the_state_does_not_matter, subscribe_to: [{B, options}]}\n"
"    end\n"
"\n"
"And we will no longer need to call `sync_subscribe/2`.\n"
"\n"
"Another advantage of this approach is that it makes it straight-forward\n"
"to leverage concurrency by simply starting multiple consumers that "
"subscribe\n"
"to its producer (or producer_consumer). This can be done in the example "
"above\n"
"by simply calling start link multiple times:\n"
"\n"
"    # Start 4 consumers\n"
"    GenStage.start_link(C, :ok)\n"
"    GenStage.start_link(C, :ok)\n"
"    GenStage.start_link(C, :ok)\n"
"    GenStage.start_link(C, :ok)\n"
"\n"
"In a supervision tree, this is often done by starting multiple workers:\n"
"\n"
"    children = [\n"
"      worker(A, [0]),\n"
"      worker(B, [2]),\n"
"      worker(C, []),\n"
"      worker(C, []),\n"
"      worker(C, []),\n"
"      worker(C, [])\n"
"    ]\n"
"\n"
"    Supervisor.start_link(children, strategy: :one_for_one)\n"
"\n"
"In fact, multiple consumers is often the easiest and simplest way to\n"
"leverage concurrency in a GenStage pipeline, especially if events can\n"
"be processed out of order. For example, imagine a scenario where you\n"
"have a stream of incoming events and you need to access a number of\n"
"external services per event. Instead of building complex stages that\n"
"route events through those services, one simple mechanism to leverage\n"
"concurrency is to start a producer and N consumers and invoke the external\n"
"services directly for each event in each consumer. N is typically the\n"
"number of cores (as returned by `System.schedulers_online/0`) but can\n"
"likely be increased if the consumers are mostly waiting on IO.\n"
"\n"
"Another alternative to the scenario above, is to use a `ConsumerSupervisor`\n"
"for consuming the events instead of N consumers. The `ConsumerSupervisor`\n"
"will start a separate supervised process per event in a way you have at\n"
"most `max_demand` children and the average amount of children is\n"
"`(max_demand - min_demand) / 2`.\n"
"\n"
"## Buffering\n"
"\n"
"In many situations, producers may attempt to emit events while no consumers\n"
"have yet subscribed. Similarly, consumers may ask producers for events\n"
"that are not yet available. In such cases, it is necessary for producers\n"
"to buffer events until a consumer is available or buffer the consumer\n"
"demand until events arrive, respectively. As we will see next, buffering\n"
"events can be done automatically by `GenStage`, while buffering the demand\n"
"is a case that must be explicitly considered by developers implementing\n"
"producers.\n"
"\n"
"### Buffering events\n"
"\n"
"Due to the concurrent nature of Elixir software, sometimes a producer\n"
"may dispatch events without consumers to send those events to. For example,\n"
"imagine a `:consumer` B subscribes to `:producer` A. Next, the consumer B\n"
"sends demand to A, which uses to start producing events. Now, if the\n"
"consumer B crashes, the producer may attempt to dispatch the now produced\n"
"events but it no longer has a consumer to send those events to. In such\n"
"cases, the producer will automatically buffer the events until another\n"
"consumer subscribes.\n"
"\n"
"The buffer can also be used in cases external sources only send\n"
"events in batches larger than asked for. For example, if you are\n"
"receiving events from an external source that only sends events\n"
"in batches of 1000 and the internal demand is smaller than\n"
"that, the buffer allows you to always emit batches of 1000 events\n"
"even when the consumer has asked for less.\n"
"\n"
"In all of those cases when an event cannot be sent immediately by\n"
"a producer, the event will be automatically stored and sent the next\n"
"time consumers ask for events. The size of the buffer is configured\n"
"via the `:buffer_size` option returned by `init/1` and the default\n"
"value is 10000. If the `buffer_size` is exceeded, an error is logged.\n"
"\n"
"### Buffering demand\n"
"\n"
"In case consumers send demand and the producer is not yet ready to\n"
"fill in the demand, producers must buffer the demand until data arrives.\n"
"\n"
"As an example, let's implement a producer that broadcasts messages\n"
"to consumers. For producers, we need to consider two scenarios:\n"
"\n"
"  1. what if events arrive and there are no consumers?\n"
"  2. what if consumers send demand and there are not enough events?\n"
"\n"
"One way to implement such a broadcaster is to simply rely on the internal\n"
"buffer available in `GenStage`, dispatching events as they arrive, as "
"explained\n"
"in the previous section:\n"
"\n"
"    defmodule Broadcaster do\n"
"      use GenStage\n"
"\n"
"      @doc \"Starts the broadcaster.\"\n"
"      def start_link() do\n"
"        GenStage.start_link(__MODULE__, :ok, name: __MODULE__)\n"
"      end\n"
"\n"
"      @doc \"Sends an event and returns only after the event is dispatched."
"\"\n"
"      def sync_notify(pid, event, timeout \\\\ 5000) do\n"
"        GenStage.call(__MODULE__, {:notify, event}, timeout)\n"
"      end\n"
"\n"
"      def init(:ok) do\n"
"        {:producer, :ok, dispatcher: GenStage.BroadcastDispatcher}\n"
"      end\n"
"\n"
"      def handle_call({:notify, event}, _from, state) do\n"
"        {:reply, :ok, [event], state} # Dispatch immediately\n"
"      end\n"
"\n"
"      def handle_demand(_demand, state) do\n"
"        {:noreply, [], state} # We don't care about the demand\n"
"      end\n"
"    end\n"
"\n"
"By always sending events as soon as they arrive, if there is any demand,\n"
"we will serve the existing demand, otherwise the event will be queued in\n"
"`GenStage`'s internal buffer. In case events are being queued and not being\n"
"consumed, a log message will be emitted when we exceed the `:buffer_size`\n"
"configuration.\n"
"\n"
"While the implementation above is enough to solve the constraints above,\n"
"a more robust implementation would have tighter control over the events\n"
"and demand by tracking this data locally, leaving the `GenStage` internal\n"
"buffer only for cases where consumers crash without consuming all data.\n"
"\n"
"To handle such cases, we will make the broadcaster state a tuple with\n"
"two elements: a queue and the pending demand. When events arrive and\n"
"there are no consumers, we store the event in the queue alongside the\n"
"process information that broadcasted the event. When consumers send\n"
"demand and there are not enough events, we increase the pending demand.\n"
"Once we have both the data and the demand, we acknowledge the process\n"
"that has sent the event to the broadcaster and finally broadcast the\n"
"event downstream.\n"
"\n"
"    defmodule QueueBroadcaster do\n"
"      use GenStage\n"
"\n"
"      @doc \"Starts the broadcaster.\"\n"
"      def start_link() do\n"
"        GenStage.start_link(__MODULE__, :ok, name: __MODULE__)\n"
"      end\n"
"\n"
"      @doc \"Sends an event and returns only after the event is dispatched."
"\"\n"
"      def sync_notify(event, timeout \\\\ 5000) do\n"
"        GenStage.call(__MODULE__, {:notify, event}, timeout)\n"
"      end\n"
"\n"
"      ## Callbacks\n"
"\n"
"      def init(:ok) do\n"
"        {:producer, {:queue.new, 0}, dispatcher: GenStage."
"BroadcastDispatcher}\n"
"      end\n"
"\n"
"      def handle_call({:notify, event}, from, {queue, pending_demand}) do\n"
"        queue = :queue.in({from, event}, queue)\n"
"        dispatch_events(queue, pending_demand, [])\n"
"      end\n"
"\n"
"      def handle_demand(incoming_demand, {queue, pending_demand}) do\n"
"        dispatch_events(queue, incoming_demand + pending_demand, [])\n"
"      end\n"
"\n"
"      defp dispatch_events(queue, 0, events) do\n"
"        {:noreply, Enum.reverse(events), {queue, 0}}\n"
"      end\n"
"      defp dispatch_events(queue, demand, events) do\n"
"        case :queue.out(queue) do\n"
"          {{:value, {from, event}}, queue} ->\n"
"            GenStage.reply(from, :ok)\n"
"            dispatch_events(queue, demand - 1, [event | events])\n"
"          {:empty, queue} ->\n"
"            {:noreply, Enum.reverse(events), {queue, demand}}\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"Let's also implement a consumer that automatically subscribes to the\n"
"broadcaster on `c:init/1`. The advantage of doing so on initialization\n"
"is that, if the consumer crashes while it is supervised, the subscription\n"
"is automatically reestablished when the supervisor restarts it.\n"
"\n"
"    defmodule Printer do\n"
"      use GenStage\n"
"\n"
"      @doc \"Starts the consumer.\"\n"
"      def start_link() do\n"
"        GenStage.start_link(__MODULE__, :ok)\n"
"      end\n"
"\n"
"      def init(:ok) do\n"
"        # Starts a permanent subscription to the broadcaster\n"
"        # which will automatically start requesting items.\n"
"        {:consumer, :ok, subscribe_to: [QueueBroadcaster]}\n"
"      end\n"
"\n"
"      def handle_events(events, _from, state) do\n"
"        for event <- events do\n"
"          IO.inspect {self(), event}\n"
"        end\n"
"        {:noreply, [], state}\n"
"      end\n"
"    end\n"
"\n"
"With the broadcaster in hand, now let's start the producer as well\n"
"as multiple consumers:\n"
"\n"
"    # Start the producer\n"
"    QueueBroadcaster.start_link()\n"
"\n"
"    # Start multiple consumers\n"
"    Printer.start_link()\n"
"    Printer.start_link()\n"
"    Printer.start_link()\n"
"    Printer.start_link()\n"
"\n"
"At this point, all consumers must have sent their demand which we were\n"
"not able to fulfill. Now by calling `sync_notify`, the event shall be\n"
"broadcasted to all consumers at once as we have buffered the demand in\n"
"the producer:\n"
"\n"
"    QueueBroadcaster.sync_notify(:hello_world)\n"
"\n"
"If we had called `QueueBroadcaster.sync_notify(:hello_world)` before any\n"
"consumer was available, the event would also be buffered in our own\n"
"queue and served only when demand is received.\n"
"\n"
"By having control over the demand and queue, the `Broadcaster` has\n"
"full control on how to behave when there are no consumers, when the\n"
"queue grows too large, and so forth.\n"
"\n"
"## Asynchronous work and `handle_subscribe`\n"
"\n"
"Both producer_consumer and consumer have been designed to do their\n"
"work in the `c:handle_events/3` callback. This means that, after\n"
"`c:handle_events/3` is invoked, both producer_consumer and consumer\n"
"will immediately send demand upstream and ask for more items, as\n"
"it assumes events have been fully processed by `c:handle_events/3`.\n"
"\n"
"Such default behaviour makes producer_consumer and consumer\n"
"unfeasible for doing asynchronous work. However, given `GenStage`\n"
"was designed to run with multiple consumers, it is not a problem\n"
"to perform synchronous or blocking actions inside `handle_events/3`\n"
"as you can then start multiple consumers in order to max both CPU\n"
"and IO usage as necessary.\n"
"\n"
"On the other hand, if you must perform some work asynchronously,\n"
"`GenStage` comes with an option that manually controls how demand\n"
"is sent upstream, avoiding the default behaviour where demand is\n"
"sent after `c:handle_events/3`. Such can be done by implementing\n"
"the `c:handle_subscribe/4` callback and returning `{:manual, state}`\n"
"instead of the default `{:automatic, state}`. Once the producer mode\n"
"is set to `:manual`, developers must use `GenStage.ask/3` to send\n"
"demand upstream when necessary.\n"
"\n"
"For example, the `ConsumerSupervisor` module processes events\n"
"asynchronously by starting child process and such is done by\n"
"manually sending demand to producers. The `ConsumerSupervisor`\n"
"can be used to distribute work to a limited amount of\n"
"processes, behaving similar to a pool where a new process is\n"
"started per event. The minimum amount of concurrent children per\n"
"producer is specified by `min_demand` and the `maximum` is given\n"
"by `max_demand`. See the `ConsumerSupervisor` docs for more\n"
"information.\n"
"\n"
"Setting the demand to `:manual` in `c:handle_subscribe/4` is not\n"
"only useful for asynchronous work but also for setting up other\n"
"mechanisms for back-pressure. As an example, let's implement a\n"
"consumer that is allowed to process a limited number of events\n"
"per time interval. Those are often called rate limiters:\n"
"\n"
"    defmodule RateLimiter do\n"
"      use GenStage\n"
"\n"
"      def init(_) do\n"
"        # Our state will keep all producers and their pending demand\n"
"        {:consumer, %{}}\n"
"      end\n"
"\n"
"      def handle_subscribe(:producer, opts, from, producers) do\n"
"        # We will only allow max_demand events every 5000 miliseconds\n"
"        pending = opts[:max_demand] || 1000\n"
"        interval = opts[:interval] || 5000\n"
"\n"
"        # Register the producer in the state\n"
"        producers = Map.put(producers, from, {pending, interval})\n"
"        # Ask for the pending events and schedule the next time around\n"
"        producers = ask_and_schedule(producers, from)\n"
"\n"
"        # Returns manual as we want control over the demand\n"
"        {:manual, producers}\n"
"      end\n"
"\n"
"      def handle_cancel(_, from, producers) do\n"
"        # Remove the producers from the map on unsubscribe\n"
"        {:noreply, [], Map.delete(producers, from)}\n"
"      end\n"
"\n"
"      def handle_events(events, from, producers) do\n"
"        # Bump the amount of pending events for the given producer\n"
"        producers = Map.update!(producers, from, fn {pending, interval} ->\n"
"          {pending + length(events), interval}\n"
"        end)\n"
"\n"
"        # Consume the events by printing them.\n"
"        IO.inspect(events)\n"
"\n"
"        # A producer_consumer would return the processed events here.\n"
"        {:noreply, [], producers}\n"
"      end\n"
"\n"
"      def handle_info({:ask, from}, producers) do\n"
"        # This callback is invoked by the Process.send_after/3 message "
"below.\n"
"        {:noreply, [], ask_and_schedule(producers, from)}\n"
"      end\n"
"\n"
"      defp ask_and_schedule(producers, from) do\n"
"        case producers do\n"
"          %{^from => {pending, interval}} ->\n"
"            # Ask for any pending events\n"
"            GenStage.ask(from, pending)\n"
"            # And let's check again after interval\n"
"            Process.send_after(self(), {:ask, from}, interval)\n"
"            # Finally, reset pending events to 0\n"
"            Map.put(producers, from, {0, interval})\n"
"          %{} ->\n"
"            producers\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"With the `RateLimiter` implemented, let's subscribe it to the\n"
"producer we have implemented at the beginning of the module\n"
"documentation:\n"
"\n"
"    {:ok, a} = GenStage.start_link(A, 0)\n"
"    {:ok, b} = GenStage.start_link(RateLimiter, :ok)\n"
"\n"
"    # Ask for 10 items every 2 seconds\n"
"    GenStage.sync_subscribe(b, to: a, max_demand: 10, interval: 2000)\n"
"\n"
"Although the rate limiter above is a consumer, it could be made a\n"
"producer_consumer by changing `c:init/1` to return a `:producer_consumer`\n"
"and then forwarding the events in `c:handle_events/3`.\n"
"\n"
"## Notifications\n"
"\n"
"`GenStage` also supports the ability to send notifications to all\n"
"consumers. Those notifications are sent as regular messages outside\n"
"of the demand-driven protocol but respecting the event ordering.\n"
"See `sync_notify/3` and `async_notify/2`.\n"
"\n"
"Notifications are useful for out-of-band information. For example,\n"
"to notify consumers the producer has sent all events it had to\n"
"process or that a new batch of events is starting.\n"
"\n"
"Note the notification system should not be used for broadcasting\n"
"events; for such, consider using `GenStage.BroadcastDispatcher`.\n"
"\n"
"## Callbacks\n"
"\n"
"`GenStage` is implemented on top of a `GenServer` with two additions.\n"
"Besides exposing all of the `GenServer` callbacks, it also provides\n"
"`handle_demand/2` to be implemented by producers and `handle_events/3`\n"
"to be implemented by consumers, as shown above. Furthermore, all the\n"
"callback responses have been modified to potentially emit events.\n"
"See the callbacks documentation for more information.\n"
"\n"
"By adding `use GenStage` to your module, Elixir will automatically\n"
"define all callbacks for you except the following:\n"
"\n"
"  * `init/1` - must be implemented to choose between `:producer`, `:"
"consumer` or `:producer_consumer`\n"
"  * `handle_demand/2` - must be implemented by `:producer` types\n"
"  * `handle_events/3` - must be implemented by `:producer_consumer` and `:"
"consumer` types\n"
"\n"
"Although this module exposes functions similar to the ones found in\n"
"the `GenServer` API, like `call/3` and `cast/2`, developers can also\n"
"rely directly on GenServer functions such as `GenServer.multi_call/4`\n"
"and `GenServer.abcast/3` if they wish to.\n"
"\n"
"### Name registration\n"
"\n"
"`GenStage` is bound to the same name registration rules as a `GenServer`.\n"
"Read more about it in the `GenServer` docs.\n"
"\n"
"## Message-protocol overview\n"
"\n"
"This section will describe the message-protocol implemented\n"
"by stages. By documenting these messages, we will allow\n"
"developers to provide their own stage implementations.\n"
"\n"
"### Back-pressure\n"
"\n"
"When data is sent between stages, it is done by a message\n"
"protocol that provides back-pressure. The first step is\n"
"for the consumer to subscribe to the producer. Each\n"
"subscription has a unique reference.\n"
"\n"
"Once subscribed, the consumer may ask the producer for messages\n"
"for the given subscription. The consumer may demand more items\n"
"whenever it wants to. A consumer must never receive more data\n"
"than it has asked for from any given producer stage.\n"
"\n"
"A consumer may have multiple producers, where each demand is\n"
"managed individually. A producer may have multiple consumers,\n"
"where the demand and events are managed and delivered according\n"
"to a `GenStage.Dispatcher` implementation.\n"
"\n"
"### Producer messages\n"
"\n"
"The producer is responsible for sending events to consumers\n"
"based on demand.\n"
"\n"
"  * `{:\"$gen_producer\", from :: {consumer_pid, subscription_tag}, {:"
"subscribe, current, options}}` -\n"
"    sent by the consumer to the producer to start a new subscription.\n"
"\n"
"    Before sending, the consumer MUST monitor the producer for clean-up\n"
"    purposes in case of crashes. The `subscription_tag` is unique to\n"
"    identify the subscription. It is typically the subscriber monitoring\n"
"    reference although it may be any term.\n"
"\n"
"    Once sent, the consumer MAY immediately send demand to the producer.\n"
"    The `subscription_tag` is unique to identify the subscription.\n"
"\n"
"    The `current` field, when not nil, is a two-item tuple containing a\n"
"    subscription that must be cancelled with the given reason before the\n"
"    current one is accepted.\n"
"\n"
"    Once received, the producer MUST monitor the consumer. However, if\n"
"    the subscription reference is known, it MUST send a `:cancel` message\n"
"    to the consumer instead of monitoring and accepting the subscription.\n"
"\n"
"  * `{:\"$gen_producer\", from :: {consumer_pid, subscription_tag}, {:"
"cancel, reason}}` -\n"
"    sent by the consumer to cancel a given subscription.\n"
"\n"
"    Once received, the producer MUST send a `:cancel` reply to the\n"
"    registered consumer (which may not necessarily be the one received\n"
"    in the tuple above). Keep in mind, however, there is no guarantee\n"
"    such messages can be delivered in case the producer crashes before.\n"
"    If the pair is unknown, the producer MUST send an appropriate cancel\n"
"    reply.\n"
"\n"
"  * `{:\"$gen_producer\", from :: {consumer_pid, subscription_tag}, {:ask, "
"count}}` -\n"
"    sent by consumers to ask data in a given subscription.\n"
"\n"
"    Once received, the producer MUST send data up to the demand. If the\n"
"    pair is unknown, the producer MUST send an appropriate cancel reply.\n"
"\n"
"### Consumer messages\n"
"\n"
"The consumer is responsible for starting the subscription\n"
"and sending demand to producers.\n"
"\n"
"  * `{:\"$gen_consumer\", from :: {producer_pid, subscription_tag}, {:"
"notification, msg}}` -\n"
"    notifications sent by producers.\n"
"\n"
"  * `{:\"$gen_consumer\", from :: {producer_pid, subscription_tag}, {:"
"cancel, reason}}` -\n"
"    sent by producers to cancel a given subscription.\n"
"\n"
"    It is used as a confirmation for client cancellations OR\n"
"    whenever the producer wants to cancel some upstream demand.\n"
"\n"
"  * `{:\"$gen_consumer\", from :: {producer_pid, subscription_tag}, [event]}"
"` -\n"
"    events sent by producers to consumers.\n"
"\n"
"    `subscription_tag` identifies the subscription. The third argument\n"
"    is a non-empty list of events. If the subscription is unknown, the\n"
"    events must be ignored and a cancel message sent to the producer.\n"
"\n"
msgstr ""
"ステージは、他のステージとの間でデータを送受信するデータ交換ステップです。\n"
"\n"
"ステージは、データを送信する場合は生産者として動作し、データを受信する\n"
"場合は消費者として動作します。ステージは生産者と消費者の役割を同時に\n"
"持つこともできます。\n"
"\n"
"## ステージのタイプ\n"
"\n"
"ステージは生産者と消費者の双方の役割を持つ場合を除くと、アイテムを生産\n"
"するだけの場合は「ソース」、アイテムを消費するだけの場合は「シンク」と呼ばれ"
"ます。\n"
"\n"
"たとえば、以下のステージを考えます。AはBにデータを送信し、BはCにデータを\n"
"送信します。\n"
"\n"
"    [A] -> [B] -> [C]\n"
"\n"
"これは次のように考えられます。\n"
"\n"
"  * Aは生産者の役割だけです（したがって、ソースです）。\n"
"  * Bは生産者と消費者の双方の役割を持ちます。\n"
"  * Cは消費者の役割だけです（したがって、シンクです）。\n"
"\n"
"次の節の例で見るように、ステージを実装する際にはその型を\n"
"指定しなければなりません。\n"
"\n"
"イベントの流れを開始するために、消費者を生産者に登録します。\n"
"両者の間で通信チャネルが確立したら、消費者は生産者にイベントを\n"
"依頼します。通常、これを消費者は上流に要求を送信すると言います。\n"
"要求が届いたら、生産者は項目を発行します。消費者が望む以上の項目を\n"
"発行することはありません。これによりバックプレッシャー機構を提供します。\n"
"\n"
"消費者は複数の生産者を持つことができ、生産者は複数の消費者を持つことが\n"
"できます。消費者がデータを要求した場合、各生産者はその要求を独立に処理\n"
"します。生産者は要求を受け付けると複数の消費者にデータを送信します。要求は\n"
"追跡され、イベントはディスパッチャにより送信されます。これにより、生産者は\n"
"様々な「戦略」でデータを送信できます。詳細は`GenStage.Dispatcher`を参照\n"
"してください。\n"
"多くの開発者は並行性を実現するために、A、B、Cのようなステージのレイヤーを\n"
"作成する傾向があります。しかし、それはGenStageの誤用です。Elixirの\n"
"プロセスは並行性を実現するための抽象化です。なぜなら、VMがこれらのプロセス"
"を\n"
"多重化する作業をすべて行うためです。GenStageのレイヤーを作成しなければ\n"
"ならないのは、バックプレッシャが必要な場合や様々な方法でデータをルーティン"
"グ\n"
"する必要がある場合です。\n"
"\n"
"たとえば、データを多段階に渡って処理する必要があるが、バックプレッシャーの\n"
"必要もデータを分割する必要もない場合は、杉のように設計しないでください。\n"
"\n"
"    [生産者] -> [ステップ 1] -> [ステップ 2] -> [ステップ 3]\n"
"\n"
"代わりに、次のように設計するほうが良いです。\n"
"\n"
"                [消費者]\n"
"               /\n"
"          [生産者]--[消費者]\n"
"               \\\n"
"                [消費者]\n"
"\n"
"ここで、消費者は同じ生産者を購読する複数のプロセスであり、まったく同じ\n"
"コードを実行して、上の変換ステップのすべてを行います。`GenStage`に\n"
"含まれている`ConsumerSupervisor`モジュールはこの設計を行うための\n"
"便利な機能を提供しています。\n"
"\n"
"## 例\n"
"\n"
"以下の単純なパイプラインを定義しましょう。\n"
"\n"
"    [A] -> [B] -> [C]\n"
"\n"
"Aは0から開始する項目を発行する生産者です。Bはその項目を受信し、それに\n"
"指定された数を乗算する生産者兼消費者です。Cはそのイベントを\n"
"受信し、端末に出力します。\n"
"\n"
"Aから始めましょう。Aは生産者ですので、主な責務は要求を受信し、イベントを\n"
"生成することです。このイベントはメモリに置くか、外部のキューシステムに置く\n"
"ことができます。簡単にするために、 `init/1`時に受信した指定された`counter`"
"値\n"
"から開始する単純なカウンタを実装しましょう。\n"
"\n"
"    defmodule A do\n"
"      use GenStage\n"
"\n"
"      def start_link(number) do\n"
"        GenStage.start_link(A, number)\n"
"      end\n"
"\n"
"      def init(counter) do\n"
"        {:producer, counter}\n"
"      end\n"
"\n"
"      def handle_demand(demand, counter) when demand > 0 do\n"
"        # カウンタが3で、2項目が要求された場合、項目3と4を発行し、\n"
"        # 状態を5にセットします。\n"
"        events = Enum.to_list(counter..counter+demand-1)\n"
"        {:noreply, events, counter + demand}\n"
"      end\n"
"    end\n"
"\n"
"Bは生産者兼消費者です。これはBは明示的には要求を処理しないことを意味しま"
"す。\n"
"要求は常にその生産者に転送されるからです。AはBから要求を受信すると、Bに\n"
"イベントを送信します。イベントは望みどおりにBにより変換されます。ここでは、\n"
"Bはイベントを受信し、初期化の際に指定された数で乗算を行い、状態として格納\n"
"します。\n"
"\n"
"    defmodule B do\n"
"      use GenStage\n"
"\n"
"      def start_link(number) do\n"
"        GenStage.start_link(B, number)\n"
"      end\n"
"\n"
"      def init(number) do\n"
"        {:producer_consumer, number}\n"
"      end\n"
"\n"
"      def handle_events(events, _from, number) do\n"
"        events = Enum.map(events, & &1 * number)\n"
"        {:noreply, events, number}\n"
"      end\n"
"    end\n"
"\n"
"Cは最終的にこのイベントを受信し、1秒毎に端末に出力します。\n"
"\n"
"    defmodule C do\n"
"      use GenStage\n"
"\n"
"      def start_link() do\n"
"        GenStage.start_link(C, :ok)\n"
"      end\n"
"\n"
"      def init(:ok) do\n"
"        {:consumer, :the_state_does_not_matter}\n"
"      end\n"
"\n"
"      def handle_events(events, _from, state) do\n"
"        # 1秒待つ\n"
"        :timer.sleep(1000)\n"
"\n"
"        # イベントを出力する\n"
"        IO.inspect(events)\n"
"\n"
"        # 消費者なので項目は発行しない\n"
"        {:noreply, [], state}\n"
"      end\n"
"    end\n"
"\n"
"これでこれを開始して接続することができます。\n"
"\n"
"    {:ok, a} = A.start_link(0)  # 0から開始する\n"
"    {:ok, b} = B.start_link(2)  # 2をかける\n"
"    {:ok, c} = C.start_link()   # 状態には関心なし\n"
"\n"
"    GenStage.sync_subscribe(c, to: b)\n"
"    GenStage.sync_subscribe(b, to: a)\n"
"\n"
"通常、下から上に購読することに注意してください。AはBが\n"
"接続した場合のみ項目の生産を開始します。パイプライン全体の\n"
"準備が整った段階でこの購読は行われている必要があります。これら\n"
"すべてを購読した後、要求が上流へ流れ始め、イベントが下流に流れます。\n"
"\n"
"消費者を実装する際には、通常、購読時に`:max_demand`と`:min_demand`を\n"
"設定します。`:max_demand`は流れの中にあるべきイベントの最大量を指定し、\n"
"`:min_demand`はさらなる要求を引き起こす最小閾値を指定します。たとえば、\n"
"`:max_demand`が1000で、`:min_demand`が500の場合（これらはデフォルト値\n"
"です）、消費者は最初に1000イベントを要求し、少なくとも500イベントを受信した\n"
"後にのみ、さらなる要求を行います。\n"
"\n"
"上の例では、Bは`:producer_consumer`であり、バッファとして機能します。Bにおい"
"て\n"
"正しい要求値を得ることは重要です。なぜなら、バッファが小さすぎるとパイプライ"
"ン\n"
"全体が遅くなり、大きすぎるとメモリを不必要に消費する可能性があるからです。\n"
"\n"
"そのような値が上のステージに適用された場合、生産者はバッチ作業を行うことは\n"
"明らかです。50項目のバッチの発行を終了し、Cで消費されるにはおおよそ50秒\n"
"かかり、そこで次の50項目がリクエストされることになります。\n"
"\n"
"## `init` と `subscribe_to`\n"
"\n"
"上の例では、プロセスA、B、Cを独立に起動し、その後にそれらを購読しました。\n"
"しかし、ほとんどの場合、消費者はその`c:init/1`コールバックで生産者を購読し"
"た\n"
"方が簡単です。こうすれば、消費者がクラッシュした場合、消費者を再起動した際"
"に、\n"
"自動的に`c:init/1`が再度呼び出され、す～ばバイザを再購読することになりま"
"す。\n"
"\n"
"この方法は、消費者が起動する際に、名前（名前付けされたプロセス）または\n"
"名前付けなしで稼働している場合はPIDで生産者を参照することができれば作動しま"
"す。\n"
"たとえば、プロセスAとBが次のように起動されているとします。\n"
"\n"
"    # モジュールAのステージをAとして呼び出す\n"
"    GenStage.start_link(A, 0, name: A)\n"
"    # モジュールBのステージをBとして呼び出す\n"
"    GenStage.start_link(B, 2, name: B)\n"
"    # 消費者は購読されることがないので、名前をつける必要はない\n"
"    GenStage.start_link(C, :ok)\n"
"\n"
"これでCの`c:init/1`を次のように変更できます。\n"
"\n"
"    def init(:ok) do\n"
"      {:consumer, :the_state_does_not_matter, subscribe_to: [B]}\n"
"    end\n"
"\n"
"または、\n"
"\n"
"    def init(:ok) do\n"
"      {:consumer, :the_state_does_not_matter, subscribe_to: [{B, options}]}\n"
"    end\n"
"\n"
"そして、もう`sync_subscribe/2`を呼び必要はありません。\n"
"\n"
"この方法のもう一つの利点は各自の生産者（または生産者兼消費者）を購読する\n"
"複数の消費者を起動するだけで並行性を簡単に活用できることです。上の例で\n"
"start_linkを複数回呼ぶだけでこれを実現できます。\n"
"\n"
"    # 4つの消費者を起動する\n"
"    GenStage.start_link(C, :ok)\n"
"    GenStage.start_link(C, :ok)\n"
"    GenStage.start_link(C, :ok)\n"
"    GenStage.start_link(C, :ok)\n"
"\n"
"監視ツリーでは、これは通常複数のワーカーを起動することにより行われます。\n"
"\n"
"    children = [\n"
"      worker(A, [0]),\n"
"      worker(B, [2]),\n"
"      worker(C, []),\n"
"      worker(C, []),\n"
"      worker(C, []),\n"
"      worker(C, [])\n"
"    ]\n"
"\n"
"    Supervisor.start_link(children, strategy: :one_for_one)\n"
"\n"
"実際、複数の消費者は、通常、GenStageパイプラインにおいて並行性を活用する\n"
"もっとも容易かつ単純な方法です。イベントが順番に処理される必要がない場合は\n"
"特にそうです。たとえば、着信イベントのストリームがあり、イベントごとに数多く"
"の\n"
"外部サービスにアクセスする必要があるというシナリオを想像してください。そのよ"
"うな\n"
"サービスにイベントをルーティングする複雑なステージを構築する代わりに、並行性"
"を\n"
"活用する1つのシンプルな機構は、生産者を1つとN個の消費者を起動して、各消費者"
"に\n"
"おいて各イベントに対して直接、外部サービスを起動することです。Nは通常、\n"
"（`System.schedulers_online/0`で返される）コア数ですが、消費者がほとんどIO待"
"ち\n"
"の場合はおそらく増加させることができます。\n"
"\n"
"上のシナリオに対するもう一つの代替案はN個の消費者の代わりにイベントを消費す"
"る\n"
"ための`ConsumerSupervisor`を使用することです。`ConsumerSupervisor`は、\n"
"最大で`max_demand`個の子プロセス、平均`(max_demand - min_demand) / 2`個の\n"
"子プロセスになるように、イベントごとに独立した監視プロセスを起動します。\n"
"\n"
"## バッファリング\n"
"\n"
"多くの状況で、まだ購読する消費者が存在しなくても、生産者はイベントを発行しよ"
"うと\n"
"する場合があります。同様に、消費者はまだ利用できないイベントを生産者に要求す"
"る\n"
"場合があります。そのような場合、生産者には、消費者が現れるまでイベントを\n"
"バッファリングする、あるいは、イベントが到着するまで消費者の要求をバッファリ"
"ング\n"
"する必要があります。次節で見るように、イベントのバッファリングは`GenStage`"
"に\n"
"より自動的に行われますが、要求のバッファリングは生産者を実装する開発者が明示"
"的に\n"
"検討する必要があります。\n"
"\n"
"イベントのバッファリング\n"
"\n"
"Elixirソフトウェアの並行性の性質から、時に、イベントを送信する対象となる\n"
"消費者なしに、生産者がイベントをディスパッチする場合があります。たとえば、\n"
"`:consumer` Bが`:producer` Aを購読する場合を考えます。次に消費者Bは\n"
"Aに要求を送信して、イベントの生産を開始します。ここで消費者Bがクラッシュ\n"
"した場合、生産者は今作成したイベントをディスパッチしようとするでしょう。\n"
"しかし、もはやイベントを送信すべき消費者がありません。そのような場合、\n"
"別の消費者が行動するまで、生産者は自動的にイベントをバッファリングする\n"
"ことになります。\n"
"\n"
"バッファは、外部ソースが要求より大きな塊のイベントしか送信できない場合にも\n"
"使用できます。たとえば、一度に1000個のイベントの塊しか送信できない外部\n"
"ソースからイベントを受信しており、内部の要求がそれより少ない場合、バッファ"
"に\n"
"より、消費者の要求がそれより少なくても常に1000個のイベントの塊を発行が\n"
"可能になります。\n"
"\n"
"これらすべての場合、生産者がイベントを直ちに送信できない場合、イベントは\n"
"自動体的に格納され、次回消費者がイベントを要求した時に送信します。バッファ"
"の\n"
"サイズは`init/1`により返される`:buffer_size`オプションを介して構成されま"
"す。\n"
"デフォルト値は10000です。`buffer_size`が超過した場合はエラーがログされま"
"す。\n"
"\n"
"### 要求のバッファリング\n"
"\n"
"消費者が要求を送信したが、生産者が要求を満たす準備ができていない場合、\n"
"生産者はデータが届くまで要求をバッファリングしなければなりません。\n"
"\n"
"例のように、消費者にメッセージをブロードキャストする生産者を実装しましょ"
"う。\n"
"生産者は次の2つのシナリオを検討する必要があります。\n"
"\n"
"  1. イベントが届いたが、消費飛車がいない場合どうするか?\n"
"  2. 消費者が要求を送信したが、まだイベントがない場合どうするか?\n"
"\n"
"そのようなブロードキャストを実装する一つの方法は、先の節で説明したように、\n"
"単純に`GenStage`で利用できる内部バッファを信頼して、イベントが到着次弟\n"
"ディスパッチする方法です。\n"
"\n"
"    defmodule Broadcaster do\n"
"      use GenStage\n"
"\n"
"      @doc “ブロードキャストを開始する\"\n"
"      def start_link() do\n"
"        GenStage.start_link(__MODULE__, :ok, name: __MODULE__)\n"
"      end\n"
"\n"
"      @doc “イベントを送信して、イベントがディスパッチされた後にはじめて戻る"
"\"\n"
"      def sync_notify(pid, event, timeout \\\\ 5000) do\n"
"        GenStage.call(__MODULE__, {:notify, event}, timeout)\n"
"      end\n"
"\n"
"      def init(:ok) do\n"
"        {:producer, :ok, dispatcher: GenStage.BroadcastDispatcher}\n"
"      end\n"
"\n"
"      def handle_call({:notify, event}, _from, state) do\n"
"        {:reply, :ok, [event], state} # すぐにディスパッチする\n"
"      end\n"
"\n"
"      def handle_demand(_demand, state) do\n"
"        {:noreply, [], state} # 要求については関知しない\n"
"      end\n"
"    end\n"
"\n"
"常にイベントが到着次弟すぐにイベントを送信することにより、要求が存在する\n"
"場合はその要求に応え、そうでない場合はイベントを`GenStage`の内部バッファに\n"
"入れます。イベントがキューにあり、消費者がいない場合で、構成した`:"
"buffer_size`を\n"
"超えた場合はログメッセージが出力されます。\n"
"\n"
"上の実装は上記の制約を解決しますが、より堅牢な実装は、`GenStage`の内部\n"
"バッファは消費者が全てのデータを消費することなくクラッシュした場合の対応用"
"に\n"
"留め、イベントと要求をローカルで追跡することでこれらのデータをより厳密に\n"
"制御するものです。\n"
"\n"
"そのようなケースを処理するために、ブロードキャスタの状態を、キューと保留中の"
"要求\n"
"からなる2要素タプルにします。イベントが到着したが消費者がいない場合は、イベン"
"トを\n"
"ブロードキャストしたプロセス情報と共にイベントをキューに格納し、消費者が要求"
"を\n"
"送ったが十分なイベントがない場合は、保留中の要求を増加させます。データと要求"
"の\n"
"双方がある場合は、イベントをブロードキャスタに送信したプロセスを認識し、最後"
"に\n"
"イベントを下流にブロードキャストします。\n"
"\n"
"    defmodule QueueBroadcaster do\n"
"      use GenStage\n"
"\n"
"      @doc \"Starts the broadcaster.\"\n"
"      def start_link() do\n"
"        GenStage.start_link(__MODULE__, :ok, name: __MODULE__)\n"
"      end\n"
"\n"
"      @doc \"イベントを送信して、イベントがディスパッチされた後にはじめて戻る"
"\"\n"
"      def sync_notify(event, timeout \\\\ 5000) do\n"
"        GenStage.call(__MODULE__, {:notify, event}, timeout)\n"
"      end\n"
"\n"
"      ## コールバック\n"
"\n"
"      def init(:ok) do\n"
"        {:producer, {:queue.new, 0}, dispatcher: GenStage."
"BroadcastDispatcher}\n"
"      end\n"
"\n"
"      def handle_call({:notify, event}, from, {queue, pending_demand}) do\n"
"        queue = :queue.in({from, event}, queue)\n"
"        dispatch_events(queue, pending_demand, [])\n"
"      end\n"
"\n"
"      def handle_demand(incoming_demand, {queue, pending_demand}) do\n"
"        dispatch_events(queue, incoming_demand + pending_demand, [])\n"
"      end\n"
"\n"
"      defp dispatch_events(queue, 0, events) do\n"
"        {:noreply, Enum.reverse(events), {queue, 0}}\n"
"      end\n"
"      defp dispatch_events(queue, demand, events) do\n"
"        case :queue.out(queue) do\n"
"          {{:value, {from, event}}, queue} ->\n"
"            GenStage.reply(from, :ok)\n"
"            dispatch_events(queue, demand - 1, [event | events])\n"
"          {:empty, queue} ->\n"
"            {:noreply, Enum.reverse(events), {queue, demand}}\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"ブロードキャスタを`c:init/1`で自動的に購読する消費者も実装しましょう。\n"
"初期化の際にそれをする利点は、監視されている消費者がクラッシュした場合、\n"
"スーパーバイザが消費者を再起動した際にブロードキャスタを自動的に\n"
"再購読することです。\n"
"\n"
"    defmodule Printer do\n"
"      use GenStage\n"
"\n"
"      @doc “消費者を起動する\"\n"
"      def start_link() do\n"
"        GenStage.start_link(__MODULE__, :ok)\n"
"      end\n"
"\n"
"      def init(:ok) do\n"
"        # ブロードキャスタの永久的な購読を開始し、\n"
"        # 項目の要求を自動的に開始する。\n"
"        {:consumer, :ok, subscribe_to: [QueueBroadcaster]}\n"
"      end\n"
"\n"
"      def handle_events(events, _from, state) do\n"
"        for event <- events do\n"
"          IO.inspect {self(), event}\n"
"        end\n"
"        {:noreply, [], state}\n"
"      end\n"
"    end\n"
"\n"
"ブロードキャスタが手に入ったので、生産者と複数の消費者を起動しましょう。\n"
"\n"
"    # 生産者を起動する\n"
"    QueueBroadcaster.start_link()\n"
"\n"
"    # 複数の消費者を起動する\n"
"    Printer.start_link()\n"
"    Printer.start_link()\n"
"    Printer.start_link()\n"
"    Printer.start_link()\n"
"\n"
"この時点ですべての消費者は要求を送信したはずですが、まだそれを\n"
"満たすことはできません。ここで`sync_notify`を呼ぶことにより、イベントが\n"
"すべての消費者に直ちにブロードキャストされるはずです。生産者のバッファには\n"
"要求が溜まっているからです。\n"
"\n"
"    QueueBroadcaster.sync_notify(:hello_world)\n"
"\n"
"消費者が存在する前に`QueueBroadcaster.sync_notify(:hello_world)`を呼び出し"
"た\n"
"場合は、イベントも自身のキューにバッファリングし、要求を受信した時にのみイベ"
"ントを\n"
"提供します。\n"
"\n"
"要求とキューを制御することにより、`Broadcaster`は消費者がいない場合、\n"
"キューが大きくなりすぎた場合などにどう振る舞うかを完全に制御できます。\n"
"\n"
"## 非同期作業と`handle_subscribe`\n"
"\n"
"生産者兼消費者と消費者は、自身の作業を`c:handle_events/3`コールバックで行う\n"
"よう設計されています。これは、`c:handle_events/3`が呼び出された後、両者は\n"
"直ちに上流に要求を送信し、さらなる項目を求めることを意味します。なぜなら、\n"
"イベントはすべて`c:handle_events/3`で処理されると仮定しているからです。\n"
"\n"
"このようなデフォルトビヘイビアは、生産者兼消費者と消費者が非同期に作業するこ"
"とを\n"
"不可能にします。しかし、`GenStage`は複数の消費者で動作するよう設計されてい"
"る\n"
"ので、`handle_events/3`の内部で同期アクションやブロッキングアクションを実行\n"
"することは問題ではありません。なぜなら、必要に応じてCPUとIOの利用を最大限に\n"
"活用するために複数の消費者を起動できるからです。\n"
"\n"
"一方、作業を非同期で行わなければならない場合、`GenStage`には、\n"
"`c:handle_events/3`の処理後に要求を送信するデフォルトのふるまいを避け、\n"
"要求をどの程度上流に送信するかを手動で制御するオプションがあります。\n"
"これは`c:handle_subscribe/4`コールバックを実装し、デフォルトの\n"
"`{:automatic, state}`の代わりに`{:manual, state}`を返すことにより実現できま"
"す。\n"
"生産者モードを`:manual`に設定した場合は、必要に応じて上流に要求を送信する\n"
"際には`GenStage.ask/3`を使用しなければなりません。\n"
"\n"
"たとえば、`ConsumerSupervisor`モジュールは子プロセスを起動することにより\n"
"イベントを非同期に処理します。これは生産者に要求を手動で送信することにより\n"
"行われています。`ConsumerSupervisor`は限られた数のプロセスに作業を分散させ"
"る\n"
"ために使用できます。これはイベントごとに新しいプロセスが起動されるプールと同"
"じ\n"
"ふるまいです。生産者当りの並行実行子プロセスの最小値は`min_demand`で、\n"
"最大値は`max_demand`で指定されます。詳細は`ConsumerSupervisor`の\n"
"ドキュメントを参照してください。\n"
"\n"
"`c:handle_subscribe/4`で要求を`:manual`に設定するkとは非同期作業だけでな"
"く、\n"
"バックプレッシャのための他の機構を設定するにも有用です。例として、時間間隔ご"
"とに\n"
"限られた数のイベントを処理できる消費者を実装しましょう。これは通常レートリ"
"ミッタと\n"
"呼ばれています。\n"
"\n"
"    defmodule RateLimiter do\n"
"      use GenStage\n"
"\n"
"      def init(_) do\n"
"        # 状態はすべての生産者とその保留中の要求を保持する\n"
"        {:consumer, %{}}\n"
"      end\n"
"\n"
"      def handle_subscribe(:producer, opts, from, producers) do\n"
"        # 5000ミリ秒ごとにmax_demand個のイベントのみを許容する\n"
"        pending = opts[:max_demand] || 1000\n"
"        interval = opts[:interval] || 5000\n"
"\n"
"        # 生産者を状態に登録する\n"
"        producers = Map.put(producers, from, {pending, interval})\n"
"        # 保留中のイベントを要求し、次回のスケジュールを決める\n"
"        producers = ask_and_schedule(producers, from)\n"
"\n"
"        # 要求を制御したいのでマニュアルモードを返す\n"
"        {:manual, producers}\n"
"      end\n"
"\n"
"      def handle_cancel(_, from, producers) do\n"
"        # 購読中止時にマップから生産者を削除する\n"
"        {:noreply, [], Map.delete(producers, from)}\n"
"      end\n"
"\n"
"      def handle_events(events, from, producers) do\n"
"        # 指定した生産者の保留中のイベントを増加させる\n"
"        producers = Map.update!(producers, from, fn {pending, interval} ->\n"
"          {pending + length(events), interval}\n"
"        end)\n"
"\n"
"        # 画面出力することでイベントを消費する\n"
"        IO.inspect(events)\n"
"\n"
"        # 生産者兼消費者はここで処理したイベントを返す\n"
"        {:noreply, [], producers}\n"
"      end\n"
"\n"
"      def handle_info({:ask, from}, producers) do\n"
"        # このコールバックは下の Process.send_after/3 messageにより呼び出され"
"る\n"
"        {:noreply, [], ask_and_schedule(producers, from)}\n"
"      end\n"
"\n"
"      defp ask_and_schedule(producers, from) do\n"
"        case producers do\n"
"          %{^from => {pending, interval}} ->\n"
"            # 保留中のイベントを要求する\n"
"            GenStage.ask(from, pending)\n"
"            # 指定の時間後にもう一度チェックする\n"
"            Process.send_after(self(), {:ask, from}, interval)\n"
"            # 最後に保留中のイベントを0にリセットする\n"
"            Map.put(producers, from, {0, interval})\n"
"          %{} ->\n"
"            producers\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"実装した`RateLimiter`を使って、このモジュールドキュメントの最初で\n"
"実装した生産者を購読してみましょう。\n"
"\n"
"    {:ok, a} = GenStage.start_link(A, 0)\n"
"    {:ok, b} = GenStage.start_link(RateLimiter, :ok)\n"
"\n"
"    # 2秒ごとに10項目を要求する\n"
"    GenStage.sync_subscribe(b, to: a, max_demand: 10, interval: 2000)\n"
"\n"
"上のレートリミッタは消費者ですが、`c:init/1`が`:producer_consumer`を\n"
"返し、`c:handle_events/3`の中でイベントを転送するように変更すれば、\n"
"生産者兼消費者にすることができます。\n"
"\n"
"## 通知\n"
"\n"
"`GenStage`はすべての消費者に通知を送信する機能もサポートしています。\n"
"これらの通知は要求駆動のプロトコルには含まれない通常のメッセーとして\n"
"送信されますが、イベントの順序は尊重します。`sync_notify/3`と\n"
"`async_notify/2`を参照してください。\n"
"\n"
"通知は、生産者が処理すべき全てのイベントを送信したことや新たなイベントの\n"
"塊を開始したことなど、帯域外の情報を消費者に通知するのに役立ちます。\n"
"\n"
"通知システムはイベントのブロードキャストには使用すべきではないことに\n"
"注意してください。そのような場合は、`GenStage.BroadcastDispatcher`の\n"
"使用を検討してください。\n"
"\n"
"## コールバック\n"
"\n"
"`GenStage`は`GenServer`の上に2つの追加コールバックで実装されています。\n"
"`GenServer`のすべてのコールバックを提供している他に、上で述べたように、\n"
"生産者が実装する`handle_demand/2`と、消費者が実装する`handle_events/3`が\n"
"提供されています。さらに、すべてのコールバックの応答が潜在的にイベントを発"
"行\n"
"するよう変更されています。詳細はコールバックのドキュメントを参照してくださ"
"い。\n"
"\n"
"モジュールに`use GenStage`を追加することにより、Elixirは以下を除く\n"
"すべてのコールバックを自動的に定義します。\n"
"\n"
"  * `init/1` - `:producer`、`:consumer`、`:producer_consumer`のいずれかを\n"
"    選択するために実装しなければなりません\n"
"  * `handle_demand/2` - `:producer`タイプは実装しなければなりません\n"
"  * `handle_events/3` -`:producer_consumer`と`:consumer`タイプは\n"
"    実装しなければなりません types\n"
"\n"
"このモジュールは、`call/3`や`cast/2`などのように`GenServer` APIと同じ\n"
"関数を公開していますが、望むのであれば、`GenServer.multi_call/4`や\n"
"`GenServer.abcast/3`などのGenServerの関数を直接使うこともできます。\n"
"\n"
"### 名前の登録\n"
"\n"
"`GenStage`は`GenServer`と同じ名前登録規則に従います。詳細は`GenServer`の\n"
"ドキュメントを参照してください。\n"
"\n"
"## メッセージプロトコルの概要\n"
"\n"
"この節ではステージで実装されているメッセージプロトコルを説明します。これら"
"の\n"
"メッセージをドキュメント化することにより、開発者が独自のステージ実装を提供\n"
"することを可能にします。\n"
"\n"
"### バックプレッシャ\n"
"\n"
"ステージ間でのデータの送信は、バックプレッシャを提供するメッセージプロトコル"
"に\n"
"より行われます。消費者にとっての第1ステップは生産者の購読です。各購読は\n"
"一意なリファレンスを持ちます。\n"
"\n"
"購読すると、消費者は指定した購読のメッセージを生産者に要求できます。消費者"
"は\n"
"必要な時にはいつでもさらなる項目を要求できます。消費者は指定した生産者ステー"
"ジ\n"
"から、要求した以上のデータを受信してはいけません。\n"
"\n"
"消費者は複数の生産者を購読できます。各要求は独立に管理されます。生産者は\n"
"複数の消費者を持つことができ、要求とイベントは`GenStage.Dispatcher`の\n"
"実装にしたがって、管理・配布されます。\n"
"\n"
"### 生産者へのメッセージ\n"
"\n"
"生産者は要求に基づいてイベントを消費者に送信する責任があります。\n"
"\n"
"  * `{:\"$gen_producer\", from :: {consumer_pid, subscription_tag}, {:"
"subscribe, current, options}}` -\n"
"   新たな購読を開始するために消費者から生産者に送信されます。\n"
"\n"
"    送信する前に、クラッシュした際にクリーンアップするために、消費者は\n"
"    生産者をモニターしなければ*なりません*。`subscription_tag`は購読を\n"
"    一意に識別するもので、通常は購読者のモニタリングリファレンスですが、\n"
"    任意の項でもかまいません。\n"
"\n"
"    送信後は、消費者は直ちに生産者に要求を送信*できます*。`subscription_tag`"
"は\n"
"    購読を一意に識別します。\n"
"\n"
"    `current`フィールドは、nilでない場合は、2項目タプルで、現在の購読が受け付"
"け\n"
"    られる前に指定の理由でキャンセルされるべき購読を含みます。\n"
"\n"
"    受信後、生産者は消費者をモニターしなければ*なりません*。しかし、購読\n"
"    リファレンスが既知の場合、生産者は購読を受け付けてモニターする代わりに\n"
"    `:cancel`メッセージを消費者に送信しなければ*なりません*。\n"
"\n"
"  * `{:\"$gen_producer\", from :: {consumer_pid, subscription_tag}, {:"
"cancel, reason}}` -\n"
"    指定の購読をキャンセルするために消費者により送信されます。\n"
"\n"
"    受信後、生産者は登録済消費者（必ずしも上で説明したタプルで受け取った\n"
"    ものでなくてもよい）に`:cancel`応答を送信しなければ*なりません*。\n"
"    しかし、生産者がクラッシュした場合は事前にそのようなメッセージが\n"
"    配信される保証はないことに留意してください。fromペアを知らない場合、\n"
"    生産者は適切なキャンセル応答を送信しなければ*なりません*。\n"
"\n"
"  * `{:\"$gen_producer\", from :: {consumer_pid, subscription_tag}, {:ask, "
"count}}` -\n"
"    指定した購読のデータを要求するために消費者により送信されます。\n"
"\n"
"    受信後、生産者は要求数を上限とするデータを送信しなければ*なりません*。\n"
"    fromペアを知らない場合、生産者は適切なキャンセル応答を送信しなければ\n"
"    *なりません*。\n"
"\n"
"### 消費者へのメッセージ\n"
"\n"
"消費者は生産者の購読を開始し、要求を送信する責任があります。\n"
"\n"
"\n"
"  * `{:\"$gen_consumer\", from :: {producer_pid, subscription_tag}, {:"
"notification, msg}}` -\n"
"    生産者により送信される通知です。\n"
"\n"
"  * `{:\"$gen_consumer\", from :: {producer_pid, subscription_tag}, {:"
"cancel, reason}}` -\n"
"    指定した購読をキャンセルするために生産者により送信されます。\n"
"\n"
"    クライアントのキャセル要求を確認するため、*または*、生産者が上流への要求"
"を\n"
"    キャンセルしたい場合に使用されます。\n"
"\n"
"  * `{:\"$gen_consumer\", from :: {producer_pid, subscription_tag}, [event]}"
"` -\n"
"    生産者から消費者に送信されるイベントです。\n"
"\n"
"    `subscription_tag`は購読を識別します。第3引数はイベントの空でないリストで"
"す。\n"
"    購読を知らない場合は、イベントを無視し、キャンセルメッセージを生産者に\n"
"    送信しなければなりません。\n"
"\n"

#. TRANSLATORS: @callback format_status/2
#: lib/gen_stage.ex:952
msgid "The same as `c:GenServer.format_status/2`.\n"
msgstr "`c:GenServer.format_status/2`と同じです。\n"

#. TRANSLATORS: def GenStage.reply(client, reply)
#: lib/gen_stage.ex:1332
msgid ""
"Replies to a client.\n"
"\n"
"This function can be used to explicitly send a reply to a client that\n"
"called `call/3` when the reply cannot be specified in the return value\n"
"of `handle_call/3`.\n"
"\n"
"`client` must be the `from` argument (the second argument) accepted by\n"
"`handle_call/3` callbacks. `reply` is an arbitrary term which will be given\n"
"back to the client as the return value of the call.\n"
"\n"
"Note that `reply/2` can be called from any process, not just the "
"`GenServer`\n"
"that originally received the call (as long as that `GenServer` communicated "
"the\n"
"`from` argument somehow).\n"
"\n"
"This function always returns `:ok`.\n"
"\n"
"## Examples\n"
"\n"
"    def handle_call(:reply_in_one_second, from, state) do\n"
"      Process.send_after(self(), {:reply, from}, 1_000)\n"
"      {:noreply, [], state}\n"
"    end\n"
"\n"
"    def handle_info({:reply, from}, state) do\n"
"      GenStage.reply(from, :one_second_has_passed)\n"
"    end\n"
"\n"
msgstr ""
"クライアントに応答します。\n"
"\n"
"この関数は`、`handle_call/3`の返り値では応答を指定できなかった場合に、\n"
"call/3`を呼び出したクライアントに応答を明示的に送信するために使用できます。\n"
"\n"
"`client`は`handle_call/3`コールバックで受け付けた`from`引数（第2要素）で\n"
"なければなりません。`reply`は、呼び出しの返り値としてクライアントに\n"
"返される任意の項です。\n"
"\n"
"`reply/2`は呼び出しを最初に受けた`GenServer`だけでなく（`GenServer`が\n"
"何らかの形で`from`引数と通信している限り）任意のプロセスから呼び出すことが\n"
"できることに注意してください。\n"
"\n"
"この関数は常に`:ok`を返します。\n"
"\n"
"## 例\n"
"\n"
"    def handle_call(:reply_in_one_second, from, state) do\n"
"      Process.send_after(self(), {:reply, from}, 1_000)\n"
"      {:noreply, [], state}\n"
"    end\n"
"\n"
"    def handle_info({:reply, from}, state) do\n"
"      GenStage.reply(from, :one_second_has_passed)\n"
"    end\n"
"\n"

#. TRANSLATORS: def GenStage.cancel(arg, reason, opts \\ [])
#: lib/gen_stage.ex:1266
msgid ""
"Cancels the given subscription on the producer.\n"
"\n"
"Once the producer receives the request, a confirmation\n"
"may be forwarded to the consumer (although there is no\n"
"guarantee as the producer may crash for unrelated reasons\n"
"before). This is an asynchronous request.\n"
"\n"
"It accepts the same options as `Process.send/3`.\n"
msgstr ""
"生産者に対する指定の購読をキャンセルします。\n"
"\n"
"生産者がこのリクエストを受信した後、確認メッセージが消費者に\n"
"転送されます（ただし、生産者がそれ以前に別の理由でクラッシュする\n"
"可能性があるので保証はありません）。これは非同期リクエストです。\n"
"\n"
"`Process.send/3`と同じオプションを受け付けます。\n"

#. TRANSLATORS: @type type
#: lib/gen_stage.ex:704
msgid "The supported stage types."
msgstr "サポートされているステージのタイプ"

#. TRANSLATORS: @callback terminate/2
#: lib/gen_stage.ex:939
msgid "The same as `c:GenServer.terminate/2`.\n"
msgstr "`c:GenServer.terminate/2`と同じです。\n"

#. TRANSLATORS: @callback handle_info/2
#: lib/gen_stage.ex:923
msgid ""
"Invoked to handle all other messages.\n"
"\n"
"`msg` is the message and `state` is the current state of the `GenStage`. "
"When\n"
"a timeout occurs the message is `:timeout`.\n"
"\n"
"If this callback is not implemented, the default implementation by\n"
"`use GenStage` will return `{:noreply, [], state}`.\n"
"\n"
"Return values are the same as `c:handle_cast/2`.\n"
msgstr ""
"その他すべてのメッセージを処理するために呼び出されます。\n"
"\n"
"`msg`はメッセージであり、`state`は`GenStage`の現在の状態です。\n"
"タイムアウトが生じた場合、メッセージは`:timeout`です。\n"
"\n"
"このコールバックが実装されていない場合、`use GenStage`によるデフォルトの\n"
"実装が`{:noreply, [], state}`を返します。\n"
"\n"
"返り値は`c:handle_cast/2`と同じです。\n"

#. TRANSLATORS: def GenStage.stream(subscriptions, options \\ [])
#: lib/gen_stage.ex:1441
msgid ""
"Creates a stream that subscribes to the given producers\n"
"and emits the appropriate messages.\n"
"\n"
"It expects a list of producers to subscribe to. Each element\n"
"represents the producer or a tuple with the producer and the\n"
"subscription options as defined in `sync_subscribe/2`. Once\n"
"all producers are subscribed to, their demand is automatically\n"
"set to `:forward` mode. See the `:demand` and `:producers`\n"
"options below for more information.\n"
"\n"
"`GenStage.stream/1` will \"hijack\" the inbox of the process\n"
"enumerating the stream to subscribe and receive messages\n"
"from producers. However it guarantees it won't remove or\n"
"leave unwanted messages in the mailbox after enumeration\n"
"except if one of the producers come from a remote node.\n"
"For more information, read the \"Known limitations\" section\n"
"below.\n"
"\n"
"## Options\n"
"\n"
"  * `:demand` - configures the demand to `:forward` or `:accumulate`\n"
"    mode. See `c:init/1` and `demand/2` for more information.\n"
"\n"
"  * `:producers` - the processes to set the demand to `:forward`\n"
"    on subscription. It defaults to the processes being subscribed\n"
"    to. Sometimes the stream is subscribing to a `:producer_consumer`\n"
"    instead of a `:producer`, in such cases, you can set this option\n"
"    to either an empty list or the list of actual producers so they\n"
"    receive the proper notification message.\n"
"\n"
"## Known limitations\n"
"\n"
"### from_enumerable\n"
"\n"
"This module also provides a function called `from_enumerable/2`\n"
"which receives an enumerable (like a stream) and creates a stage\n"
"that emits data from the enumerable.\n"
"\n"
"Given both `GenStage.from_enumerable/2` and `GenStage.stream/1`\n"
"require the process inbox to send and receive messages, it is\n"
"impossible to run a `stream/1` inside a `from_enumerable/2` as\n"
"the `stream/1` will never receive the messages it expects.\n"
"\n"
"### Remote nodes\n"
"\n"
"While it is possible to stream messages from remote nodes\n"
"such should be done with care. In particular, in case of\n"
"disconnections, there is a chance the producer will send\n"
"messages after the consumer receives its DOWN messages and\n"
"those will remain in the process inbox, violating the\n"
"common scenario where `GenStage.stream/1` does not pollute\n"
"the caller inbox. In such cases, it is recommended to\n"
"consume such streams from a separate process which will be\n"
"discarded after the stream is consumed.\n"
msgstr ""
"指定した生産者を購読するストリームを作成し、適切なメッセージを発行します。\n"
"\n"
"購読する生産者のリストを指定します。リストの各要素は生産者か、\n"
"生産者と`sync_subscribe/2`で定義されている購読オプションからなるタプルを\n"
"表します。すべての生産者が購読されると、それらへの要求は自動的に`:forward`\n"
"モードに設定されます。詳細は以下の`:demand`オプションと`:producers`\n"
"オプションを参照してください。\n"
"\n"
"`GenStage.stream/1`は生産者からのメッセージを購読したり、受信する\n"
"ためにストリームを列挙するプロセスの受信ボックスを「乗っ取り」ます。\n"
"しかし、生産者のいずれかがリモートノードにある場合を除いて、列挙後に\n"
"不要なメッセージを削除したり、残したりすることはありません。詳細は\n"
"下の「既知の制限事項」を参照してください。\n"
"\n"
"## オプション\n"
"\n"
"  * `:demand` - 要求モードを`:forward`か`:accumulate`に構成します。\n"
"    詳細は`c:init/1`と`demand/2`を参照してください。\n"
"\n"
"  * `:producers` - 購読時に要求モードを`:forward`に設定するプロセス。\n"
"    デフォルトは購読されているプロセスです。ストリームは`:producer`の代わり"
"に\n"
"    `:producer_consumer`を購読することもあります。そのような場合は、\n"
"    このオプションに空のリストまたは実際の生産者のリストを設定して、適切な\n"
"    通知メッセージを受け取るようにすることができます。\n"
"\n"
"## 既知の制限事項\n"
"\n"
"### from_enumerable\n"
"\n"
"このモジュールは（ストリームなどの）enumerableを受け取り、enumrableから\n"
"データを発行するステージを作成する`from_enumerable/2`という関数も提供して\n"
"います。\n"
"\n"
"`GenStage.from_enumerable/2`も`GenStage.stream/1`もメッセージを送受信\n"
"するためにプロセスの受信ボックスを必要とするので、`from_enumerable/2`の\n"
"内部で`stream/1`を実行することはできません。`stream/1`が期待するメッセージ"
"を\n"
"受信することはけっしてないからです。\n"
"\n"
"### リモートノード\n"
"\n"
"リモートノードからメッセージを流すことは可能ですが、慎重に行う必要がありま"
"す。\n"
"特に、切断された場合、消費者がDOWNメッセージを受信後に生産者がメッセージを\n"
"送信すると、そのメッセージは消費者の受信ボックスに残り、`GenStage.stream/1`"
"は\n"
"呼び出し側の受信ボックスを汚染しないという一般的なシナリオに違反する可能性"
"が\n"
"あります。そのような場合は、ストリームを消費した後に破棄される別のプロセスか"
"ら\n"
"そのようなストリームを消費することを勧めます。\n"
"\n"

#. TRANSLATORS: @callback handle_cancel/3
#: lib/gen_stage.ex:829
msgid ""
"Invoked when a consumer is no longer subscribed to a producer.\n"
"\n"
"It receives the cancellation reason, the `from` tuple and the state.\n"
"The `cancel_reason` will be a `{:cancel, _}` tuple if the reason for\n"
"cancellation was a `GenStage.cancel/2` call. Any other value means\n"
"the cancellation reason was due to an EXIT.\n"
"\n"
"If this callback is not implemented, the default implementation by\n"
"`use GenStage` will return `{:noreply, [], state}`.\n"
"\n"
"Return values are the same as `c:handle_cast/2`.\n"
msgstr ""
"消費者が生産者の購読をしなくなった時に呼び出されます。\n"
"\n"
"キャンセルの理由と`from`タプル、状態を引数に取ります。キャンセルの\n"
"理由が`GenStage.cancel/2`の呼び出しだった場合、`cancel_reason`は\n"
"`{:cancel, _}`タプルになります。その他の値はキャンセルの理由がEXITで\n"
"あったことを意味します。\n"
"\n"
"このコールバックが実装されていない場合、`use GenStage`によるデフォルトの\n"
"実装が`{:noreply, [], state}`を返します。\n"
"\n"
"返り値は`c:handle_cast/2`と同じです。\n"

#. TRANSLATORS: def GenStage.from_enumerable(stream, opts \\ [])
#: lib/gen_stage.ex:1389
msgid ""
"Starts a producer stage from an enumerable (or stream).\n"
"\n"
"This function will start a stage linked to the current process\n"
"that will take items from the enumerable when there is demand.\n"
"Since streams are enumerables, we can also pass streams as\n"
"arguments (in fact, streams are the most common argument to\n"
"this function).\n"
"\n"
"The enumerable is consumed in batches, retrieving `max_demand`\n"
"items the first time and then `max_demand - min_demand` the\n"
"next times. Therefore, for streams that cannot produce items\n"
"that fast, it is recommended to pass a lower `:max_demand`\n"
"value as an option.\n"
"\n"
"When the enumerable finishes or halts, a notification is sent\n"
"to all consumers in the format of\n"
"`{{pid, subscription_tag}, {:producer, :halted | :done}}`. If the\n"
"stage is meant to terminate when there are no more consumers, we\n"
"recommend setting the `:consumers` option to `:permanent`.\n"
"\n"
"Keep in mind that streams that require the use of the process\n"
"inbox to work most likely won't behave as expected with this\n"
"function since the mailbox is controlled by the stage process\n"
"itself.\n"
"\n"
"## Options\n"
"\n"
"  * `:link` - when false, does not link the stage to the current\n"
"    process. Defaults to `true`\n"
"\n"
"  * `:consumers` - when `:permanent`, the stage exits when there\n"
"    are no more consumers. Defaults to `:temporary`\n"
"\n"
"  * `:dispatcher` - the dispatcher responsible for handling demands.\n"
"    Defaults to `GenStage.DemandDispatch`. May be either an atom or\n"
"    a tuple with the dispatcher and the dispatcher options\n"
"\n"
"  * `:demand` - configures the demand to `:forward` or `:accumulate`\n"
"    mode. See `c:init/1` and `demand/2` for more information.\n"
"\n"
"All other options that would be given for `start_link/3` are\n"
"also accepted.\n"
msgstr ""
"enumerable（またはストリーム）から生産者ステージを起動します。\n"
"\n"
"この関数は現在のプロセスのリンクしたステージを起動します。このステージは\n"
"要求があった場合、enumerableから項目を取得します。ストリームはenumerable\n"
"なので、引数としてストリームを渡すこともできます（実際、ストリームは\n"
"この関数の引数としてもっともありふれたものです）。\n"
"\n"
"enumerableは塊で消費されます。初回に`max_demand`個の項目が取り出され、\n"
"次回からは`max_demand - min_demand`個が取り出されます。そのため、それほど\n"
"早く項目を生産できないストリームには、オプションとして小さな値の`:max_demand`"
"を\n"
"渡すことを勧めます。\n"
"\n"
"enumerableが終了または停止した場合、\n"
"`{{pid, subscription_tag}, {:producer, :halted | :done}}`形式の通知がすべて"
"の\n"
"消費者に送信されます。消費者がなくなった時にステージを終了させる場合は、\n"
"`:consumers`オプションに`:permanent`を設定することを勧めます。\n"
"\n"
"メールボックスはステージプロセス自身により制御されるので、動作にプロセスの\n"
"受信ボックスの使用が必要なストリームでは、この関数が期待どおりに動作しない\n"
"可能性が高いことに留意してください。\n"
"\n"
"## オプション\n"
"\n"
"  * `:link` - `false`の場合、ステージを現在のプロセスにリンクしません。デフォ"
"ルトは\n"
"    `true`です。\n"
"\n"
"  * `:consumers` - `:permanent`の場合、消費者がなくなった時にステージは\n"
"    終了します。デフォルトは`:temporary`です。\n"
"\n"
"  * `:dispatcher` - 要求の処理を担当するディスパッチャです。デフォルトは\n"
"    `GenStage.DemandDispatch`です。アトムか、ディスパッチャとディスパッチャ\n"
"    オプションからなるタプルのいずれかを指定できます。\n"
"\n"
"  * `:demand` - 要求モードを`:forward`か`:accumulate`のいずれかに構成しま"
"す。\n"
"    詳細は`c:init/1`と`demand/2`を参照してください。 \n"
"\n"
"`start_link/3`で指定可能な他のすべてのオプションも受け付けます。\n"

#. TRANSLATORS: def GenStage.call(stage, request, timeout \\ 5000)
#: lib/gen_stage.ex:1287
msgid ""
"Makes a synchronous call to the `stage` and waits for its reply.\n"
"\n"
"The client sends the given `request` to the server and waits until a reply\n"
"arrives or a timeout occurs. `handle_call/3` will be called on the stage\n"
"to handle the request.\n"
"\n"
"`stage` can be any of the values described in the \"Name registration\"\n"
"section of the documentation for this module.\n"
"\n"
"## Timeouts\n"
"\n"
"`timeout` is an integer greater than zero which specifies how many\n"
"milliseconds to wait for a reply, or the atom `:infinity` to wait\n"
"indefinitely. The default value is `5000`. If no reply is received within\n"
"the specified time, the function call fails and the caller exits. If the\n"
"caller catches the failure and continues running, and the stage is just "
"late\n"
"with the reply, it may arrive at any time later into the caller's message\n"
"queue. The caller must in this case be prepared for this and discard any "
"such\n"
"garbage messages that are two-element tuples with a reference as the first\n"
"element.\n"
msgstr ""
"`stage`の同期的呼び出しを行い、応答を待ちます。\n"
"\n"
"クライアントは指定の`request`をサーバに送信し、応答が届くか、\n"
"タイムアウトが発生するまで待ちます。リクエストを処理するために\n"
"ステージ上で`handle_call/3`が呼び出されます。\n"
"\n"
"`stage`は、このモジュールのドキュメントの「名前の登録」セクションに\n"
"記述されているいずれかの値です。\n"
"\n"
"## タイムアウト\n"
"\n"
"`timeout`は、応答をどれだけ待つかをミリ秒単位で指定する0より大きな整数か、\n"
"永久に待ち続けることを意味するアトム`:infinity`のいずれかです。デフォルト値"
"は\n"
"5000です。指定した時間内に応答を受信しなかった場合、この関数は失敗し、呼び出"
"し\n"
"元は終了します。呼び出し元が失敗を捕捉して実行を継続しており、ステージは\n"
"単に応答が遅いだけの場合、その後のいつかに応答は呼び出し元のメッセージキュー"
"に\n"
"届きます。この場合、呼び出し元はこれに備えて、第1要素としてリファレンスを持"
"つ\n"
"2要素タプルのゴミクズメッセージを無視しなければなりません。\n"

#. TRANSLATORS: @type options
#: lib/gen_stage.ex:707
msgid "The supported init options"
msgstr "サポートされている初期化オプション"

#. TRANSLATORS: def GenStage.demand(stage, mode)
#: lib/gen_stage.ex:1124
msgid ""
"Sets the demand mode for a producer.\n"
"\n"
"When `:forward`, the demand is always forwarded to the `handle_demand`\n"
"callback. When `:accumulate`, demand is accumulated until its mode is\n"
"set to `:forward`. This is useful as a synchronization mechanism, where\n"
"the demand is accumulated until all consumers are subscribed. Defaults\n"
"to `:forward`.\n"
"\n"
"This command is asynchronous.\n"
msgstr ""
"生産者への要求モードを設定します。\n"
"\n"
"モードが`:forward`の場合、要求は常に`handle_demand`コールバックに\n"
"転送されます。`:accumulate`の場合、要求はモードが`:forward`に設定される\n"
"まで蓄積されます。これは、すべての消費者が購読するまで要求を蓄積する\n"
"同期機構として役立ちます。デフォルトは`:forward`です。\n"
"\n"
"このコマンドは非同期です。\n"

#. TRANSLATORS: @callback handle_call/3
#: lib/gen_stage.ex:859
msgid ""
"Invoked to handle synchronous `call/3` messages. `call/3` will block until "
"a\n"
"reply is received (unless the call times out or nodes are disconnected).\n"
"\n"
"`request` is the request message sent by a `call/3`, `from` is a 2-tuple\n"
"containing the caller's PID and a term that uniquely identifies the call, "
"and\n"
"`state` is the current state of the `GenStage`.\n"
"\n"
"Returning `{:reply, reply, [events], new_state}` sends the response `reply`\n"
"to the caller after events are dispatched (or buffered) and continues the\n"
"loop with new state `new_state`.  In case you want to deliver the reply "
"before\n"
"the processing events, use `GenStage.reply/2` and return `{:noreply, "
"[event],\n"
"state}` (see below).\n"
"\n"
"Returning `{:noreply, [event], new_state}` does not send a response to the\n"
"caller and processes the given events before continuing the loop with new\n"
"state `new_state`. The response must be sent with `reply/2`.\n"
"\n"
"Hibernating is also supported as an atom to be returned from either\n"
"`:reply` and `:noreply` tuples.\n"
"\n"
"Returning `{:stop, reason, reply, new_state}` stops the loop and "
"`terminate/2`\n"
"is called with reason `reason` and state `new_state`. Then the `reply` is "
"sent\n"
"as the response to call and the process exits with reason `reason`.\n"
"\n"
"Returning `{:stop, reason, new_state}` is similar to\n"
"`{:stop, reason, reply, new_state}` except a reply is not sent.\n"
"\n"
"If this callback is not implemented, the default implementation by\n"
"`use GenStage` will return `{:stop, {:bad_call, request}, state}`.\n"
msgstr ""
"`call/3`メッセージを同期的に処理するために呼び出されます。`call/3`は\n"
"（呼び出しがタイムアウトするかノードが切断されないない限り）応答を\n"
"受信するまでブロックします。\n"
"\n"
"`request`は`call/3`により送信されたリクエストメッセージであり、`from`は\n"
"呼び出し元のPIDと呼び出しを一意に識別する項を含む2要素タプルであり、\n"
"`state`は`GenStage`の現在の状態です。\n"
"\n"
"`{:reply, reply, [events]`を返すと、イベントがディスパッチ（またはバッファリ"
"ング）\n"
"された後、応答`reply`が呼び出し元に送信され、新たな状態`new_state`でループ"
"を\n"
"継続します。イベントを処理する前に応答を配信した場合は、`GenStage.reply/2`"
"を\n"
"使用して、`{:noreply, [event], state}`を返してください（以下を参照）。\n"
"\n"
"`{:noreply, [event], new_state}`を返すと、呼び出し元に応答は返さず、指定の\n"
"イベントを処理した後、新たな状態`new_state`でループを継続します。応答は\n"
"`reply/2`で送信されなかればなりません。\n"
"\n"
"ハイバネーションも`:reply`または`:noreply`タプルのいずれかから返される\n"
"アトムとしてサポートされています。\n"
"\n"
"`{:stop, reason, reply, new_state}`を返すと、ループを停止し、理由`reason`と\n"
"状態`new_state`を引数に`terminate/2`が呼び出されます。その後、`reply`が\n"
"呼び出しの応答として送信され、プロセスは理由`reason`で終了します。\n"
"\n"
"`{:stop, reason, new_state}`は応答が送信されないことを除いて\n"
"`{:stop, reason, reply, new_state}`と同じです。\n"
"\n"
"このコールバックが実装されていない場合、`use GenStage`によるデフォルトの\n"
"実装が`{:stop, {:bad_call, request}, state}`を返します。\n"

#. TRANSLATORS: def GenStage.ask(producer, demand, opts \\ [])
#: lib/gen_stage.ex:1242
msgid ""
"Asks the given demand to the producer.\n"
"\n"
"The demand is a non-negative integer with the amount of events to\n"
"ask a producer for. If the demand is 0, it simply returns `:ok`\n"
"without asking for data.\n"
"\n"
"This function must only be used in the rare cases when a consumer\n"
"sets a subscription to `:manual` mode in the `c:handle_subscribe/4`\n"
"callback.\n"
"\n"
"It accepts the same options as `Process.send/3`.\n"
msgstr ""
"生産者に指定の`demand`を要求します。\n"
"\n"
"`demand`は生産者に要求するイベントの量を示す非負の整数です。\n"
"`demand`が0の場合は、データを要求することなく単に`:ok`を返します。\n"
"\n"
"この関数は、消費者が`c:handle_subscribe/4`コールバックで購読を\n"
"`:manual`モードに設定した稀な場合に限り使用されるべきです。\n"
"\n"
"`Process.send/3`と同じオプションを受け付けます。\n"

#. TRANSLATORS: @callback handle_events/3
#: lib/gen_stage.ex:847
msgid ""
"Invoked on :producer_consumer and :consumer stages to handle events.\n"
"\n"
"Must always be explicitly implemented by such types.\n"
"\n"
"Return values are the same as `c:handle_cast/2`.\n"
msgstr ""
":producer_consumerステージと:consumerステージでイベントを処理するために\n"
"呼び出されます。\n"
"\n"
"これらのタイプのステージでは常に明示的に実装する必要があります。\n"
"\n"
"返り値は`c:handle_cast/2`と同じです。\n"
"\n"

#. TRANSLATORS: def GenStage.async_notify(stage, msg)
#: lib/gen_stage.ex:1104
msgid ""
"Asks the producer to send a notification to all consumers asynchronously.\n"
"\n"
"The given message will be delivered in the format\n"
"`{{producer_pid, subscription_tag}, msg}`, where `msg` is the message\n"
"given below. `subscription_tag` is the subscription tag passed to the\n"
"consumer's `c:handle_subscribe/4` callback in the `to_or_from` tuple.\n"
"Consumers that wish to verify the `subscription_tag` in their\n"
"`c:handle_info/2` implementation should store such subscription tag in\n"
"their state.\n"
"\n"
"This call returns `:ok` regardless if the notification has been\n"
"received by the producer or sent. It is typically called from\n"
"the producer stage itself.\n"
msgstr ""
"すべての消費者に非同期に通知を送信するよう生産者に要求します。\n"
"\n"
"指定したメッセージが`{{producer_pid, subscription_tag}, msg}`形式で\n"
"配信されます。ここで、`msg`は指定したメッセージです。`subscription_tag`は\n"
"`to_or_from`タプルの中で消費者の`c:handle_subscribe/4`コールバックに\n"
"渡される購読タグです。`c:handle_info/2`の実装において、`subscription_tag`を\n"
"検証したい消費者は購読タグを自分の状態に格納するべきです。\n"
"\n"
"この関数は、通知が生産者により受信されたのか、送信されたのかにかかわらず\n"
"`:ok`を返します。通常は生産者ステージ自身により呼び出されます。\n"

#. TRANSLATORS: @type stage
#: lib/gen_stage.ex:710
msgid "The stage reference"
msgstr "ステージリファレンス"

#. TRANSLATORS: def GenStage.sync_resubscribe(stage, ref, reason, opts, timeout \\ 5000)
#: lib/gen_stage.ex:1182
msgid ""
"Cancels `ref` with `reason` and subscribe synchronously in one step.\n"
"\n"
"See `sync_subscribe/3` for examples and options.\n"
msgstr ""
"一回の操作で、`ref`を`reason`でキャンセルし、同期的に購読します。\n"
"\n"
"例とオプションは`sync_subscribe/3`を参照してください。\n"

#. TRANSLATORS: @callback init/1
#: lib/gen_stage.ex:713
msgid ""
"Invoked when the server is started.\n"
"\n"
"`start_link/3` (or `start/3`) will block until it returns. `args`\n"
"is the argument term (second argument) passed to `start_link/3`.\n"
"\n"
"In case of successful start, this callback must return a tuple\n"
"where the first element is the stage type, which is either\n"
"a `:producer`, `:consumer` or `:producer_consumer` if it is\n"
"taking both roles.\n"
"\n"
"For example:\n"
"\n"
"    def init(args) do\n"
"      {:producer, some_state}\n"
"    end\n"
"\n"
"The returned tuple may also contain 3 or 4 elements. The third\n"
"element may be the `:hibernate` atom or a set of options defined\n"
"below.\n"
"\n"
"Returning `:ignore` will cause `start_link/3` to return `:ignore`\n"
"and the process will exit normally without entering the loop or\n"
"calling `terminate/2`.\n"
"\n"
"Returning `{:stop, reason}` will cause `start_link/3` to return\n"
"`{:error, reason}` and the process to exit with reason `reason`\n"
"without entering the loop or calling `terminate/2`.\n"
"\n"
"## Options\n"
"\n"
"This callback may return options. Some options are specific to\n"
"the stage type while others are shared across all types.\n"
"\n"
"### :producer options\n"
"\n"
"  * `:demand` - when `:forward`, the demand is always forwarded to\n"
"    the `handle_demand` callback. When `:accumulate`, demand is\n"
"    accumulated until its mode is set to `:forward` via `demand/2`.\n"
"    This is useful as a synchronization mechanism, where the demand\n"
"    is accumulated until all consumers are subscribed. Defaults to\n"
"    `:forward`.\n"
"\n"
"### :producer and :producer_consumer options\n"
"\n"
"  * `:buffer_size` - the size of the buffer to store events\n"
"    without demand. Check the \"Buffer events\" section on the\n"
"    module documentation (defaults to 10000 for `:producer`,\n"
"    `:infinity` for `:producer_consumer`)\n"
"  * `:buffer_keep` - returns if the `:first` or `:last` (default) entries\n"
"    should be kept on the buffer in case we exceed the buffer size\n"
"  * `:dispatcher` - the dispatcher responsible for handling demands.\n"
"    Defaults to `GenStage.DemandDispatch`. May be either an atom or\n"
"    a tuple with the dispatcher and the dispatcher options\n"
"\n"
"### :consumer and :producer_consumer options\n"
"\n"
"  * `:subscribe_to` - a list of producers to subscribe to. Each element\n"
"    represents the producer or a tuple with the producer and the\n"
"    subscription options (as defined in `sync_subscribe/2`)\n"
"\n"
"## Dispatcher\n"
"\n"
"When using a `:producer` or `:producer_consumer`, the dispatcher\n"
"may be configured on init as follows:\n"
"\n"
"    {:producer, state, dispatcher: GenStage.BroadcastDispatcher}\n"
"\n"
"Some dispatchers may require options to be given on initialization,\n"
"those can be done with a tuple:\n"
"\n"
"    {:producer, state, dispatcher: {GenStage.PartitionDispatcher, "
"partitions: 0..3}}\n"
"\n"
msgstr ""
"サーバーが起動する際に呼び出されれます。\n"
"\n"
"`start_link/3`（または`start/3`）はこの関数が返るまでブロックします。\n"
"`args`は`start_link/3`に（第2引数として）渡された引数の項です。\n"
"\n"
"起動が成功した場合、このコールバックは第1要素にステージのタイプを\n"
"持つタプルを返さなければなりません。ステージのタイプは`:producer`か\n"
"`:consumer`、その両方の役割を果たす場合は`:producer_consumer`の\n"
"いずれかです。\n"
"\n"
"たとえば、\n"
"\n"
"    def init(args) do\n"
"      {:producer, some_state}\n"
"    end\n"
"\n"
"返されるタプルには第3、第4要素を含めることもできます。第3要素は\n"
"`:hibernate`アトムか、以下で定義されるオプションのセットです。\n"
"\n"
"`:ignore`を返すと、`start_link/3`が`:ignore`を返すことになり、\n"
"プロセスはループに入ることなく、あるいは`terminate/2`を呼び出すことなく\n"
"正常終了します。\n"
"\n"
"`{:stop, reason}`を返すと、`start_link/3`が`{:error, reason}`を返すことにな"
"り、\n"
"プロセスはループに入ることなく、あるいは`terminate/2`を呼び出すことなく\n"
"理由`reason`で終了します。\n"
"\n"
"## オプション\n"
"\n"
"このコールバックはオプションを返すことができます。オプションには特定の\n"
"ステージタイプに固有なものもあれば、両タイプで共通なものもあります。\n"
"\n"
"### :producerのオプション\n"
"\n"
"  * `:demand` - `:forward`の場合、要求は常に`handle_demand`コールバックに\n"
"    転送されます。`:accumulate`の場合、このモードが`demand/2`により\n"
"    `:forward`に設定されるまで、要求は蓄積されます。これは同期メカニズムに\n"
"    とって有用です。すべての消費者が購読されるまで要求が蓄積されるからで"
"す。\n"
"    デフォルトは`:forward`です。\n"
"\n"
"### :producerと:producer_consumerのオプション\n"
"\n"
"  * `:buffer_size` - 要求がない場合にイベントを格納するためのバッファのサイ"
"ズ\n"
"    です。このモジュールのドキュメントの「イベントのバッファ」をチェック\n"
"    してください（デフォルトは`:producer`では10000、`:producer_consumer`で"
"は\n"
"    `:infinity`です）\n"
"  * `:buffer_keep` - バッファサイズを超過した場合、バッファ上の`:first`と\n"
"    `:last`（デフォルト）のどちらの項目を保持するかを返します。\n"
"  * `:dispatcher` - 要求の処理を担当するディスパッチャです。デフォルトは\n"
"    `GenStage.DemandDispatch`です。アトム、またはディスパッチャと\n"
"    ディスパッチャオプションからなるタプルのいずれかを設定できます。\n"
"\n"
"### :consumerと:producer_consumerのオプション\n"
"\n"
"  * `:subscribe_to` - 購読する生産者のリストです。リストの各要素は生産者"
"か、\n"
"    生産者と（`sync_subscribe/2`で定義されている）購読オプションからなる\n"
"    タプルです。\n"
"\n"
"## ディスパッチャ\n"
"\n"
"`:producer`または`:producer_consumer`を使用する場合、次のように\n"
"ディスパッチャを構成することができます。\n"
"\n"
"    {:producer, state, dispatcher: GenStage.BroadcastDispatcher}\n"
"\n"
"ディスパッチャの中には初期化時にオプションを指定する必要があるものがありま"
"す。\n"
"これはタプルを使って行うことができます。\n"
"\n"
"    {:producer, state, dispatcher: {GenStage.PartitionDispatcher, "
"partitions: 0..3}}\n"
"\n"
"\n"
