#. TRANSLATORS: @callback handle_cast/2
#: lib/gen_stage.ex:872 
msgid ""
"Invoked to handle asynchronous `cast/2` messages.\n"
"\n"
"`request` is the request message sent by a `cast/2` and `state` is the current\n"
"state of the `GenStage`.\n"
"\n"
"Returning `{:noreply, [event], new_state}` dispatches the events and continues\n"
"the loop with new state `new_state`.\n"
"\n"
"Returning `{:noreply, [event], new_state, :hibernate}` is similar to\n"
"`{:noreply, new_state}` except the process is hibernated before continuing the\n"
"loop.\n"
"\n"
"Returning `{:stop, reason, new_state}` stops the loop and `terminate/2` is\n"
"called with the reason `reason` and state `new_state`. The process exits with\n"
"reason `reason`.\n"
"\n"
"If this callback is not implemented, the default implementation by\n"
"`use GenStage` will return `{:stop, {:bad_cast, request}, state}`.\n"
msgstr ""
#. TRANSLATORS: @callback code_change/3
#: lib/gen_stage.ex:919 
msgid ""
"The same as `c:GenServer.code_change/3`.\n"
msgstr ""
#. TRANSLATORS: def GenStage.async_subscribe(stage, opts)
#: lib/gen_stage.ex:1167 
msgid ""
"Asks the consumer to subscribe to the given producer asynchronously.\n"
"\n"
"This call returns `:ok` regardless if the subscription\n"
"effectively happened or not. It is typically called from\n"
"a stage's `init/1` callback.\n"
"\n"
"## Options\n"
"\n"
"  * `:cancel` - `:permanent` (default) or `:temporary`. When permanent,\n"
"    the consumer exits when the producer cancels or exits. In case\n"
"    of exits, the same reason is used to exit the consumer. In case of\n"
"    cancellations, the reason is wrapped in a `:cancel` tuple.\n"
"  * `:min_demand` - the minimum demand for this subscription\n"
"  * `:max_demand` - the maximum demand for this subscription\n"
"\n"
"All other options are sent as is to the producer stage.\n"
msgstr ""
#. TRANSLATORS: def GenStage.start(module, args, options \\ [])
#: lib/gen_stage.ex:1043 
msgid ""
"Starts a `GenStage` process without links (outside of a supervision tree).\n"
"\n"
"See `start_link/3` for more information.\n"
msgstr ""
#. TRANSLATORS: def GenStage.stop(stage, reason \\ :normal, timeout \\ :infinity)
#: lib/gen_stage.ex:1339 
msgid ""
"Stops the stage with the given `reason`.\n"
"\n"
"The `terminate/2` callback of the given `stage` will be invoked before\n"
"exiting. This function returns `:ok` if the server terminates with the\n"
"given reason; if it terminates with another reason, the call exits.\n"
"\n"
"This function keeps OTP semantics regarding error reporting.\n"
"If the reason is any other than `:normal`, `:shutdown` or\n"
"`{:shutdown, _}`, an error report is logged.\n"
msgstr ""
#. TRANSLATORS: def GenStage.start_link(module, args, options \\ [])
#: lib/gen_stage.ex:996 
msgid ""
"Starts a `GenStage` process linked to the current process.\n"
"\n"
"This is often used to start the `GenStage` as part of a supervision tree.\n"
"\n"
"Once the server is started, the `init/1` function of the given `module` is\n"
"called with `args` as its arguments to initialize the stage. To ensure a\n"
"synchronized start-up procedure, this function does not return until `init/1`\n"
"has returned.\n"
"\n"
"Note that a `GenStage` started with `start_link/3` is linked to the\n"
"parent process and will exit in case of crashes from the parent. The `GenStage`\n"
"will also exit due to the `:normal` reasons in case it is configured to trap\n"
"exits in the `init/1` callback.\n"
"\n"
"## Options\n"
"\n"
"  * `:name` - used for name registration as described in the \"Name\n"
"    registration\" section of the module documentation\n"
"\n"
"  * `:timeout` - if present, the server is allowed to spend the given amount of\n"
"    milliseconds initializing or it will be terminated and the start function\n"
"    will return `{:error, :timeout}`\n"
"\n"
"  * `:debug` - if present, the corresponding function in the [`:sys`\n"
"    module](http://www.erlang.org/doc/man/sys.html) is invoked\n"
"\n"
"  * `:spawn_opt` - if present, its value is passed as options to the\n"
"    underlying process as in `Process.spawn/4`\n"
"\n"
"## Return values\n"
"\n"
"If the server is successfully created and initialized, this function returns\n"
"`{:ok, pid}`, where `pid` is the pid of the server. If a process with the\n"
"specified server name already exists, this function returns\n"
"`{:error, {:already_started, pid}}` with the pid of that process.\n"
"\n"
"If the `init/1` callback fails with `reason`, this function returns\n"
"`{:error, reason}`. Otherwise, if it returns `{:stop, reason}`\n"
"or `:ignore`, the process is terminated and this function returns\n"
"`{:error, reason}` or `:ignore`, respectively.\n"
msgstr ""
#. TRANSLATORS: def GenStage.sync_subscribe(stage, opts, timeout \\ 5000)
#: lib/gen_stage.ex:1106 
msgid ""
"Asks the consumer to subscribe to the given producer synchronously.\n"
"\n"
"This call is synchronous and will return after the called consumer\n"
"sends the subscribe message to the producer. It does not, however,\n"
"wait for the subscription confirmation. Therefore this function\n"
"will return before `handle_subscribe` is called in the consumer.\n"
"In other words, it guarantees the message was sent, but it does not\n"
"guarantee a subscription has effectively been established.\n"
"\n"
"This function will return `{:ok, ref}` as long as the subscription\n"
"message is sent. It may return `{:error, :not_a_consumer}` in case\n"
"the stage is not a consumer.\n"
"\n"
"## Options\n"
"\n"
"  * `:cancel` - `:permanent` (default) or `:temporary`. When permanent,\n"
"    the consumer exits when the producer cancels or exits. In case\n"
"    of exits, the same reason is used to exit the consumer. In case of\n"
"    cancellations, the reason is wrapped in a `:cancel` tuple.\n"
"  * `:min_demand` - the minimum demand for this subscription\n"
"  * `:max_demand` - the maximum demand for this subscription\n"
"\n"
"Any other option is sent to the producer stage. This may be used by\n"
"dispatchers for custom configuration. For example, if a producer uses\n"
"a `GenStage.BroadcastDispatcher`,  an optional `:selector` function\n"
"that receives an event and returns a boolean limits this subscription to\n"
"receiving only those events where the selector function returns a truthy\n"
"value:\n"
"\n"
"    GenStage.sync_subscribe(consumer,\n"
"      to: producer,\n"
"      selector: fn %{key: key} -> String.starts_with?(key, \"foo-\") end)\n"
"\n"
"All other options are sent as is to the producer stage.\n"
msgstr ""
#. TRANSLATORS: def GenStage.async_notify(stage, msg)
#: lib/gen_stage.ex:1074 
msgid ""
"Asks the producer to send a notification to all consumers asynchronously.\n"
"\n"
"The given message will be delivered in the format\n"
"`{{producer_pid, subscription_tag}, msg}`, where `msg` is the message\n"
"given below.\n"
"\n"
"This call returns `:ok` regardless if the notification has been\n"
"received by the producer or sent. It is typically called from\n"
"the producer stage itself.\n"
msgstr ""
#. TRANSLATORS: def GenStage.cast(stage, request)
#: lib/gen_stage.ex:1280 
msgid ""
"Sends an asynchronous request to the `stage`.\n"
"\n"
"This function always returns `:ok` regardless of whether\n"
"the destination `stage` (or node) exists. Therefore it\n"
"is unknown whether the destination `stage` successfully\n"
"handled the message.\n"
"\n"
"`handle_cast/2` will be called on the stage to handle\n"
"the request. In case the `stage` is on a node which is\n"
"not yet connected to the caller one, the call is going to\n"
"block until a connection happens.\n"
msgstr ""
#. TRANSLATORS: @callback handle_demand/2
#: lib/gen_stage.ex:767 
msgid ""
"Invoked on :producer stages.\n"
"\n"
"Must always be explicitly implemented by `:producer` types.\n"
"It is invoked with the demand from consumers/dispatcher. The\n"
"producer must either store the demand or return the events requested.\n"
msgstr ""
#. TRANSLATORS: @callback format_status/2
#: lib/gen_stage.ex:926 
msgid ""
"The same as `c:GenServer.format_status/2`.\n"
msgstr ""
#. TRANSLATORS: def GenStage.reply(client, reply)
#: lib/gen_stage.ex:1298 
msgid ""
"Replies to a client.\n"
"\n"
"This function can be used to explicitly send a reply to a client that\n"
"called `call/3` when the reply cannot be specified in the return value\n"
"of `handle_call/3`.\n"
"\n"
"`client` must be the `from` argument (the second argument) accepted by\n"
"`handle_call/3` callbacks. `reply` is an arbitrary term which will be given\n"
"back to the client as the return value of the call.\n"
"\n"
"Note that `reply/2` can be called from any process, not just the `GenServer`\n"
"that originally received the call (as long as that `GenServer` communicated the\n"
"`from` argument somehow).\n"
"\n"
"This function always returns `:ok`.\n"
"\n"
"## Examples\n"
"\n"
"    def handle_call(:reply_in_one_second, from, state) do\n"
"      Process.send_after(self(), {:reply, from}, 1_000)\n"
"      {:noreply, [], state}\n"
"    end\n"
"\n"
"    def handle_info({:reply, from}, state) do\n"
"      GenStage.reply(from, :one_second_has_passed)\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def GenStage.cancel(arg, reason, opts \\ [])
#: lib/gen_stage.ex:1232 
msgid ""
"Cancels the given subscription on the producer.\n"
"\n"
"Once the producer receives the request, a confirmation\n"
"may be forwarded to the consumer (although there is no\n"
"guarantee as the producer may crash for unrelated reasons\n"
"before). This is an asynchronous request.\n"
"\n"
"It accepts the same options as `Process.send/3`.\n"
msgstr ""
#. TRANSLATORS: @callback handle_subscribe/4
#: lib/gen_stage.ex:779 
msgid ""
"Invoked when a consumer subscribes to a producer.\n"
"\n"
"This callback is invoked in both producers and consumers.\n"
"\n"
"For consumers, successful subscriptions must return `{:automatic, new_state}`\n"
"or `{:manual, state}`. The default is to return `:automatic`, which means\n"
"the stage implementation will take care of automatically sending demand to\n"
"producers. `:manual` must be used when a special behaviour is desired\n"
"(for example, `ConsumerSupervisor` uses `:manual` demand) and demand must\n"
"be sent explicitly with `ask/2`. The manual subscription must be cancelled\n"
"when `handle_cancel/3` is called.\n"
"\n"
"For producers, successful subscriptions must always return\n"
"`{:automatic, new_state}`, the `:manual` mode is not supported.\n"
"\n"
"If this callback is not implemented, the default implementation by\n"
"`use GenStage` will return `{:automatic, state}`.\n"
msgstr ""
#. TRANSLATORS: def GenStage.async_resubscribe(stage, ref, reason, opts)
#: lib/gen_stage.ex:1190 
msgid ""
"Cancels `ref` with `reason` and subscribe asynchronously in one step.\n"
"\n"
"See `async_subscribe/2` for examples and options.\n"
msgstr ""
#. TRANSLATORS: @type type
#: lib/gen_stage.ex:678 
msgid ""
"The supported stage types."
msgstr ""
#. TRANSLATORS: @callback terminate/2
#: lib/gen_stage.ex:913 
msgid ""
"The same as `c:GenServer.terminate/2`.\n"
msgstr ""
#. TRANSLATORS: @callback handle_info/2
#: lib/gen_stage.ex:897 
msgid ""
"Invoked to handle all other messages.\n"
"\n"
"`msg` is the message and `state` is the current state of the `GenStage`. When\n"
"a timeout occurs the message is `:timeout`.\n"
"\n"
"If this callback is not implemented, the default implementation by\n"
"`use GenStage` will return `{:noreply, [], state}`.\n"
"\n"
"Return values are the same as `c:handle_cast/2`.\n"
msgstr ""
#. TRANSLATORS: def GenStage.stream(subscriptions, options \\ [])
#: lib/gen_stage.ex:1407 
msgid ""
"Creates a stream that subscribes to the given producers\n"
"and emits the appropriate messages.\n"
"\n"
"It expects a list of producers to subscribe to. Each element\n"
"represents the producer or a tuple with the producer and the\n"
"subscription options as defined in `sync_subscribe/2`. Once\n"
"all producers are subscribed to, their demand is automatically\n"
"set to `:forward` mode. See the `:demand` and `:producers`\n"
"options below for more information.\n"
"\n"
"`GenStage.stream/1` will \"hijack\" the inbox of the process\n"
"enumerating the stream to subscribe and receive messages\n"
"from producers. However it guarantees it won't remove or\n"
"leave unwanted messages in the mailbox after enumeration\n"
"except if one of the producers come from a remote node.\n"
"For more information, read the \"Known limitations\" section\n"
"below.\n"
"\n"
"## Options\n"
"\n"
"  * `:demand` - configures the demand to `:forward` or `:accumulate`\n"
"    mode. See `c:init/1` and `demand/2` for more information.\n"
"\n"
"  * `:producers` - the processes to set the demand to `:forward`\n"
"    on subscription. It defaults to the processes being subscribed\n"
"    to. Sometimes the stream is subscribing to a `:producer_consumer`\n"
"    instead of a `:producer`, in such cases, you can set this option\n"
"    to either an empty list or the list of actual producers so they\n"
"    receive the proper notification message.\n"
"\n"
"## Known limitations\n"
"\n"
"### from_enumerable\n"
"\n"
"This module also provides a function called `from_enumerable/2`\n"
"which receives an enumerable (like a stream) and creates a stage\n"
"that emits data from the enumerable.\n"
"\n"
"Given both `GenStage.from_enumerable/2` and `GenStage.stream/1`\n"
"require the process inbox to send and receive messages, it is\n"
"impossible to run a `stream/1` inside a `from_enumerable/2` as\n"
"the `stream/1` will never receive the messages it expects.\n"
"\n"
"### Remote nodes\n"
"\n"
"While it is possible to stream messages from remote nodes\n"
"such should be done with care. In particular, in case of\n"
"disconnections, there is a chance the producer will send\n"
"messages after the consumer receives its DOWN messages and\n"
"those will remain in the process inbox, violating the\n"
"common scenario where `GenStage.stream/1` does not pollute\n"
"the caller inbox. In such cases, it is recommended to\n"
"consume such streams from a separate process which will be\n"
"discarded after the stream is consumed.\n"
msgstr ""
#. TRANSLATORS: @callback handle_cancel/3
#: lib/gen_stage.ex:803 
msgid ""
"Invoked when a consumer is no longer subscribed to a producer.\n"
"\n"
"It receives the cancellation reason, the `from` tuple and the state.\n"
"The `cancel_reason` will be a `{:cancel, _}` tuple if the reason for\n"
"cancellation was a `GenStage.cancel/2` call. Any other value means\n"
"the cancellation reason was due to an EXIT.\n"
"\n"
"If this callback is not implemented, the default implementation by\n"
"`use GenStage` will return `{:noreply, [], state}`.\n"
"\n"
"Return values are the same as `c:handle_cast/2`.\n"
msgstr ""
#. TRANSLATORS: def GenStage.from_enumerable(stream, opts \\ [])
#: lib/gen_stage.ex:1355 
msgid ""
"Starts a producer stage from an enumerable (or stream).\n"
"\n"
"This function will start a stage linked to the current process\n"
"that will take items from the enumerable when there is demand.\n"
"Since streams are enumerables, we can also pass streams as\n"
"arguments (in fact, streams are the most common argument to\n"
"this function).\n"
"\n"
"The enumerable is consumed in batches, retrieving `max_demand`\n"
"items the first time and then `max_demand - min_demand` the\n"
"next times. Therefore, for streams that cannot produce items\n"
"that fast, it is recommended to pass a lower `:max_demand`\n"
"value as an option.\n"
"\n"
"When the enumerable finishes or halts, a notification is sent\n"
"to all consumers in the format of\n"
"`{{pid, subscription_tag}, {:producer, :halted | :done}}`. If the\n"
"stage is meant to terminate when there are no more consumers, we\n"
"recommend setting the `:consumers` option to `:permanent`.\n"
"\n"
"Keep in mind that streams that require the use of the process\n"
"inbox to work most likely won't behave as expected with this\n"
"function since the mailbox is controlled by the stage process\n"
"itself.\n"
"\n"
"## Options\n"
"\n"
"  * `:link` - when false, does not link the stage to the current\n"
"    process. Defaults to `true`\n"
"\n"
"  * `:consumers` - when `:permanent`, the stage exits when there\n"
"    are no more consumers. Defaults to `:temporary`\n"
"\n"
"  * `:dispatcher` - the dispatcher responsible for handling demands.\n"
"    Defaults to `GenStage.DemandDispatch`. May be either an atom or\n"
"    a tuple with the dispatcher and the dispatcher options\n"
"\n"
"  * `:demand` - configures the demand to `:forward` or `:accumulate`\n"
"    mode. See `c:init/1` and `demand/2` for more information.\n"
"\n"
"All other options that would be given for `start_link/3` are\n"
"also accepted.\n"
msgstr ""
#. TRANSLATORS: def GenStage.call(stage, request, timeout \\ 5000)
#: lib/gen_stage.ex:1253 
msgid ""
"Makes a synchronous call to the `stage` and waits for its reply.\n"
"\n"
"The client sends the given `request` to the server and waits until a reply\n"
"arrives or a timeout occurs. `handle_call/3` will be called on the stage\n"
"to handle the request.\n"
"\n"
"`stage` can be any of the values described in the \"Name registration\"\n"
"section of the documentation for this module.\n"
"\n"
"## Timeouts\n"
"\n"
"`timeout` is an integer greater than zero which specifies how many\n"
"milliseconds to wait for a reply, or the atom `:infinity` to wait\n"
"indefinitely. The default value is `5000`. If no reply is received within\n"
"the specified time, the function call fails and the caller exits. If the\n"
"caller catches the failure and continues running, and the stage is just late\n"
"with the reply, it may arrive at any time later into the caller's message\n"
"queue. The caller must in this case be prepared for this and discard any such\n"
"garbage messages that are two-element tuples with a reference as the first\n"
"element.\n"
msgstr ""
#. TRANSLATORS: @type options
#: lib/gen_stage.ex:681 
msgid ""
"The supported init options"
msgstr ""
#. TRANSLATORS: def GenStage.demand(stage, mode)
#: lib/gen_stage.ex:1090 
msgid ""
"Sets the demand mode for a producer.\n"
"\n"
"When `:forward`, the demand is always forwarded to the `handle_demand`\n"
"callback. When `:accumulate`, demand is accumulated until its mode is\n"
"set to `:forward`. This is useful as a synchronization mechanism, where\n"
"the demand is accumulated until all consumers are subscribed. Defaults\n"
"to `:forward`.\n"
"\n"
"This command is asynchronous.\n"
msgstr ""
#. TRANSLATORS: @callback handle_call/3
#: lib/gen_stage.ex:833 
msgid ""
"Invoked to handle synchronous `call/3` messages. `call/3` will block until a\n"
"reply is received (unless the call times out or nodes are disconnected).\n"
"\n"
"`request` is the request message sent by a `call/3`, `from` is a 2-tuple\n"
"containing the caller's PID and a term that uniquely identifies the call, and\n"
"`state` is the current state of the `GenStage`.\n"
"\n"
"Returning `{:reply, reply, [events], new_state}` sends the response `reply`\n"
"to the caller after events are dispatched (or buffered) and continues the\n"
"loop with new state `new_state`.  In case you want to deliver the reply before\n"
"the processing events, use `GenStage.reply/2` and return `{:noreply, [event],\n"
"state}` (see below).\n"
"\n"
"Returning `{:noreply, [event], new_state}` does not send a response to the\n"
"caller and processes the given events before continuing the loop with new\n"
"state `new_state`. The response must be sent with `reply/2`.\n"
"\n"
"Hibernating is also supported as an atom to be returned from either\n"
"`:reply` and `:noreply` tuples.\n"
"\n"
"Returning `{:stop, reason, reply, new_state}` stops the loop and `terminate/2`\n"
"is called with reason `reason` and state `new_state`. Then the `reply` is sent\n"
"as the response to call and the process exits with reason `reason`.\n"
"\n"
"Returning `{:stop, reason, new_state}` is similar to\n"
"`{:stop, reason, reply, new_state}` except a reply is not sent.\n"
"\n"
"If this callback is not implemented, the default implementation by\n"
"`use GenStage` will return `{:stop, {:bad_call, request}, state}`.\n"
msgstr ""
#. TRANSLATORS: def GenStage.sync_notify(stage, msg, timeout \\ 5000)
#: lib/gen_stage.ex:1053 
msgid ""
"Asks the producer to send a notification to all consumers synchronously.\n"
"\n"
"This call is synchronous and will return after the producer has either\n"
"sent the notification to all consumers or placed it in a buffer. In\n"
"other words, it guarantees the producer has handled the message but not\n"
"that the consumers have received it.\n"
"\n"
"The given message will be delivered in the format\n"
"`{{producer_pid, subscription_tag}, msg}`, where `msg` is the message\n"
"given below.\n"
"\n"
"This function will return `:ok` as long as the notification request is\n"
"sent. It may return `{:error, :not_a_producer}` in case the stage is not\n"
"a producer.\n"
msgstr ""
#. TRANSLATORS: def GenStage.ask(producer, demand, opts \\ [])
#: lib/gen_stage.ex:1208 
msgid ""
"Asks the given demand to the producer.\n"
"\n"
"The demand is a non-negative integer with the amount of events to\n"
"ask a producer for. If the demand is 0, it simply returns `:ok`\n"
"without asking for data.\n"
"\n"
"This function must only be used in the rare cases when a consumer\n"
"sets a subscription to `:manual` mode in the `c:handle_subscribe/4`\n"
"callback.\n"
"\n"
"It accepts the same options as `Process.send/3`.\n"
msgstr ""
#. TRANSLATORS: @callback handle_events/3
#: lib/gen_stage.ex:821 
msgid ""
"Invoked on :producer_consumer and :consumer stages to handle events.\n"
"\n"
"Must always be explicitly implemented by such types.\n"
"\n"
"Return values are the same as `c:handle_cast/2`.\n"
msgstr ""
#. TRANSLATORS: @type stage
#: lib/gen_stage.ex:684 
msgid ""
"The stage reference"
msgstr ""
#. TRANSLATORS: def GenStage.sync_resubscribe(stage, ref, reason, opts, timeout \\ 5000)
#: lib/gen_stage.ex:1148 
msgid ""
"Cancels `ref` with `reason` and subscribe synchronously in one step.\n"
"\n"
"See `sync_subscribe/3` for examples and options.\n"
msgstr ""
#. TRANSLATORS: @callback init/1
#: lib/gen_stage.ex:687 
msgid ""
"Invoked when the server is started.\n"
"\n"
"`start_link/3` (or `start/3`) will block until it returns. `args`\n"
"is the argument term (second argument) passed to `start_link/3`.\n"
"\n"
"In case of successful start, this callback must return a tuple\n"
"where the first element is the stage type, which is either\n"
"a `:producer`, `:consumer` or `:producer_consumer` if it is\n"
"taking both roles.\n"
"\n"
"For example:\n"
"\n"
"    def init(args) do\n"
"      {:producer, some_state}\n"
"    end\n"
"\n"
"The returned tuple may also contain 3 or 4 elements. The third\n"
"element may be the `:hibernate` atom or a set of options defined\n"
"below.\n"
"\n"
"Returning `:ignore` will cause `start_link/3` to return `:ignore`\n"
"and the process will exit normally without entering the loop or\n"
"calling `terminate/2`.\n"
"\n"
"Returning `{:stop, reason}` will cause `start_link/3` to return\n"
"`{:error, reason}` and the process to exit with reason `reason`\n"
"without entering the loop or calling `terminate/2`.\n"
"\n"
"## Options\n"
"\n"
"This callback may return options. Some options are specific to\n"
"the stage type while others are shared across all types.\n"
"\n"
"### :producer options\n"
"\n"
"  * `:demand` - when `:forward`, the demand is always forwarded to\n"
"    the `handle_demand` callback. When `:accumulate`, demand is\n"
"    accumulated until its mode is set to `:forward` via `demand/2`.\n"
"    This is useful as a synchronization mechanism, where the demand\n"
"    is accumulated until all consumers are subscribed. Defaults to\n"
"    `:forward`.\n"
"\n"
"### :producer and :producer_consumer options\n"
"\n"
"  * `:buffer_size` - the size of the buffer to store events\n"
"    without demand. Check the \"Buffer events\" section on the\n"
"    module documentation (defaults to 10000 for `:producer`,\n"
"    `:infinity` for `:producer_consumer`)\n"
"  * `:buffer_keep` - returns if the `:first` or `:last` (default) entries\n"
"    should be kept on the buffer in case we exceed the buffer size\n"
"  * `:dispatcher` - the dispatcher responsible for handling demands.\n"
"    Defaults to `GenStage.DemandDispatch`. May be either an atom or\n"
"    a tuple with the dispatcher and the dispatcher options\n"
"\n"
"### :consumer and :producer_consumer options\n"
"\n"
"  * `:subscribe_to` - a list of producers to subscribe to. Each element\n"
"    represents the producer or a tuple with the producer and the\n"
"    subscription options (as defined in `sync_subscribe/2`)\n"
"\n"
"## Dispatcher\n"
"\n"
"When using a `:producer` or `:producer_consumer`, the dispatcher\n"
"may be configured on init as follows:\n"
"\n"
"    {:producer, state, dispatcher: GenStage.BroadcastDispatcher}\n"
"\n"
"Some dispatchers may require options to be given on initialization,\n"
"those can be done with a tuple:\n"
"\n"
"    {:producer, state, dispatcher: {GenStage.PartitionDispatcher, partitions: 0..3}}\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.GenStage Summary
#: lib/gen_stage.ex:2 
msgid ""
"Stages are computation steps that send and/or receive data\n"
"from other stages.\n"
"\n"
"When a stage sends data, it acts as a producer. When it receives\n"
"data, it acts as a consumer. Stages may take both producer and\n"
"consumer roles at once.\n"
"\n"
"## Stage types\n"
"\n"
"Besides taking both producer and consumer roles, a stage may be\n"
"called \"source\" if it only produces items or called \"sink\" if it\n"
"only consumes items.\n"
"\n"
"For example, imagine the stages below where A sends data to B\n"
"that sends data to C:\n"
"\n"
"    [A] -> [B] -> [C]\n"
"\n"
"we conclude that:\n"
"\n"
"  * A is only a producer (and therefore a source)\n"
"  * B is both producer and consumer\n"
"  * C is only a consumer (and therefore a sink)\n"
"\n"
"As we will see in the upcoming Examples section, we must\n"
"specify the type of the stage when we implement each of them.\n"
"\n"
"To start the flow of events, we subscribe consumers to\n"
"producers. Once the communication channel between them is\n"
"established, consumers will ask the producers for events.\n"
"We typically say the consumer is sending demand upstream.\n"
"Once demand arrives, the producer will emit items, never\n"
"emitting more items than the consumer asked for. This provides\n"
"a back-pressure mechanism.\n"
"\n"
"A consumer may have multiple producers and a producer may have\n"
"multiple consumers. When a consumer asks for data, each producer\n"
"is handled separately, with its own demand. When a producer\n"
"receives demand and sends data to multiple consumers, the demand\n"
"is tracked and the events are sent by a dispatcher. This allows\n"
"producers to send data using different \"strategies\". See\n"
"`GenStage.Dispatcher` for more information.\n"
"\n"
"## Example\n"
"\n"
"Let's define the simple pipeline below:\n"
"\n"
"    [A] -> [B] -> [C]\n"
"\n"
"where A is a producer that will emit items starting from 0,\n"
"B is a producer-consumer that will receive those items and\n"
"multiply them by a given number and C will receive those events\n"
"and print them to the terminal.\n"
"\n"
"Let's start with A. Since A is a producer, its main\n"
"responsibility is to receive demand and generate events.\n"
"Those events may be in memory or an external queue system.\n"
"For simplicity, let's implement a simple counter starting\n"
"from a given value of `counter` received on `init/1`:\n"
"\n"
"    defmodule A do\n"
"      use GenStage\n"
"\n"
"      def start_link(number) do\n"
"        GenStage.start_link(A, number)\n"
"      end\n"
"\n"
"      def init(counter) do\n"
"        {:producer, counter}\n"
"      end\n"
"\n"
"      def handle_demand(demand, counter) when demand > 0 do\n"
"        # If the counter is 3 and we ask for 2 items, we will\n"
"        # emit the items 3 and 4, and set the state to 5.\n"
"        events = Enum.to_list(counter..counter+demand-1)\n"
"        {:noreply, events, counter + demand}\n"
"      end\n"
"    end\n"
"\n"
"B is a producer-consumer. This means it does not explicitly\n"
"handle the demand because the demand is always forwarded to\n"
"its producer. Once A receives the demand from B, it will send\n"
"events to B which will be transformed by B as desired. In\n"
"our case, B will receive events and multiply them by a number\n"
"given on initialization and stored as the state:\n"
"\n"
"    defmodule B do\n"
"      use GenStage\n"
"\n"
"      def start_link(number) do\n"
"        GenStage.start_link(B, number)\n"
"      end\n"
"\n"
"      def init(number) do\n"
"        {:producer_consumer, number}\n"
"      end\n"
"\n"
"      def handle_events(events, _from, number) do\n"
"        events = Enum.map(events, & &1 * number)\n"
"        {:noreply, events, number}\n"
"      end\n"
"    end\n"
"\n"
"C will finally receive those events and print them every second\n"
"to the terminal:\n"
"\n"
"    defmodule C do\n"
"      use GenStage\n"
"\n"
"      def start_link() do\n"
"        GenStage.start_link(C, :ok)\n"
"      end\n"
"\n"
"      def init(:ok) do\n"
"        {:consumer, :the_state_does_not_matter}\n"
"      end\n"
"\n"
"      def handle_events(events, _from, state) do\n"
"        # Wait for a second.\n"
"        :timer.sleep(1000)\n"
"\n"
"        # Inspect the events.\n"
"        IO.inspect(events)\n"
"\n"
"        # We are a consumer, so we would never emit items.\n"
"        {:noreply, [], state}\n"
"      end\n"
"    end\n"
"\n"
"Now we can start and connect them:\n"
"\n"
"    {:ok, a} = A.start_link(0)  # starting from zero\n"
"    {:ok, b} = B.start_link(2)  # multiply by 2\n"
"    {:ok, c} = C.start_link()   # state does not matter\n"
"\n"
"    GenStage.sync_subscribe(c, to: b)\n"
"    GenStage.sync_subscribe(b, to: a)\n"
"\n"
"Notice we typically subscribe from bottom to top. Since A will\n"
"start producing items only when B connects to it, we want this\n"
"subscription to happen when the whole pipeline is ready. After\n"
"you subscribe all of them, demand will start flowing upstream and\n"
"events downstream.\n"
"\n"
"When implementing consumers, we often set the `:max_demand` and\n"
"`:min_demand` on subscription. The `:max_demand` specifies the\n"
"maximum amount of events that must be in flow while the `:min_demand`\n"
"specifies the minimum threshold to trigger for more demand. For\n"
"example, if `:max_demand` is 1000 and `:min_demand` is 500\n"
"(the default values), the consumer will ask for 1000 events initially\n"
"and ask for more only after it receives at least 500.\n"
"\n"
"In the example above, B is a `:producer_consumer` and therefore\n"
"acts as a buffer. Getting the proper demand values in B is\n"
"important: making the buffer too small may make the whole pipeline\n"
"slower, making the buffer too big may unnecessarily consume\n"
"memory.\n"
"\n"
"When such values are applied to the stages above, it is easy\n"
"to see the producer works in batches. The producer A ends-up\n"
"emitting batches of 50 items which will take approximately\n"
"50 seconds to be consumed by C, which will then request another\n"
"batch of 50 items.\n"
"\n"
"## `init` and `subscribe_to`\n"
"\n"
"In the example above, we have started the processes A, B and C\n"
"independently and subscribed them later on. But most often it is\n"
"simpler to subscribe a consumer to its producer on its `c:init/1`\n"
"callback. This way, if the consumer crashes, restarting the consumer\n"
"will automatically re-invoke its `c:init/1` callback and resubscribe\n"
"it to the supervisor.\n"
"\n"
"This approach works as long as the producer can be referenced when\n"
"the consumer starts--such as by name (for a named process) or by pid\n"
"for a running unnamed process.  For example, assuming the process\n"
"`A` and `B` are started as follows:\n"
"\n"
"    # Let's call the stage in module A as A\n"
"    GenStage.start_link(A, 0, name: A)\n"
"    # Let's call the stage in module B as B\n"
"    GenStage.start_link(B, 2, name: B)\n"
"    # No need to name consumers as they won't be subscribed to\n"
"    GenStage.start_link(C, :ok)\n"
"\n"
"We can now change the `c:init/1` callback for C to the following:\n"
"\n"
"    def init(:ok) do\n"
"      {:consumer, :the_state_does_not_matter, subscribe_to: [B]}\n"
"    end\n"
"\n"
"Or:\n"
"\n"
"    def init(:ok) do\n"
"      {:consumer, :the_state_does_not_matter, subscribe_to: [{B, options}]}\n"
"    end\n"
"\n"
"And we will no longer need to call `sync_subscribe/2`.\n"
"\n"
"Another advantage of this approach is that it makes it straight-forward\n"
"to leverage concurrency by simply starting multiple consumers that subscribe\n"
"to its producer (or producer_consumer). This can be done in the example above\n"
"by simply calling start link multiple times:\n"
"\n"
"    # Start 4 consumers\n"
"    GenStage.start_link(C, :ok)\n"
"    GenStage.start_link(C, :ok)\n"
"    GenStage.start_link(C, :ok)\n"
"    GenStage.start_link(C, :ok)\n"
"\n"
"In a supervision tree, this is often done by starting multiple workers:\n"
"\n"
"    children = [\n"
"      worker(A, [0]),\n"
"      worker(B, [2]),\n"
"      worker(C, []),\n"
"      worker(C, []),\n"
"      worker(C, []),\n"
"      worker(C, [])\n"
"    ]\n"
"\n"
"    Supervisor.start_link(children, strategy: :one_for_one)\n"
"\n"
"In fact, multiple consumers is often the easiest and simplest way to\n"
"leverage concurrency in a GenStage pipeline, especially if events can\n"
"be processed out of order. For example, imagine a scenario where you\n"
"have a stream of incoming events and you need to access a number of\n"
"external services per event. Instead of building complex stages that\n"
"route events through those services, one simple mechanism to leverage\n"
"concurrency is to start a producer and N consumers and invoke the external\n"
"services directly for each event in each consumer. N is typically the\n"
"number of cores (as returned by `System.schedulers_online/0`) but can\n"
"likely be increased if the consumers are mostly waiting on IO.\n"
"\n"
"Another alternative to the scenario above, is to use a `ConsumerSupervisor`\n"
"for consuming the events instead of N consumers. The `ConsumerSupervisor`\n"
"will start a separate supervised process per event in a way you have at\n"
"most `max_demand` children and the average amount of children is\n"
"`(max_demand - min_demand) / 2`.\n"
"\n"
"## Buffering\n"
"\n"
"In many situations, producers may attempt to emit events while no consumers\n"
"have yet subscribed. Similarly, consumers may ask producers for events\n"
"that are not yet available. In such cases, it is necessary for producers\n"
"to buffer events until a consumer is available or buffer the consumer\n"
"demand until events arrive, respectively. As we will see next, buffering\n"
"events can be done automatically by `GenStage`, while buffering the demand\n"
"is a case that must be explicitly considered by developers implementing\n"
"producers.\n"
"\n"
"### Buffering events\n"
"\n"
"Due to the concurrent nature of Elixir software, sometimes a producer\n"
"may dispatch events without consumers to send those events to. For example,\n"
"imagine a `:consumer` B subscribes to `:producer` A. Next, the consumer B\n"
"sends demand to A, which uses to start producing events. Now, if the\n"
"consumer B crashes, the producer may attempt to dispatch the now produced\n"
"events but it no longer has a consumer to send those events to. In such\n"
"cases, the producer will automatically buffer the events until another\n"
"consumer subscribes.\n"
"\n"
"The buffer can also be used in cases external sources only send\n"
"events in batches larger than asked for. For example, if you are\n"
"receiving events from an external source that only sends events\n"
"in batches of 1000 and the internal demand is smaller than\n"
"that, the buffer allows you to always emit batches of 1000 events\n"
"even when the consumer has asked for less.\n"
"\n"
"In all of those cases when an event cannot be sent immediately by\n"
"a producer, the event will be automatically stored and sent the next\n"
"time consumers ask for events. The size of the buffer is configured\n"
"via the `:buffer_size` option returned by `init/1` and the default\n"
"value is 10000. If the `buffer_size` is exceeded, an error is logged.\n"
"\n"
"### Buffering demand\n"
"\n"
"In case consumers send demand and the producer is not yet ready to\n"
"fill in the demand, producers must buffer the demand until data arrives.\n"
"\n"
"As an example, let's implement a producer that broadcasts messages\n"
"to consumers. For producers, we need to consider two scenarios:\n"
"\n"
"  1. what if events arrive and there are no consumers?\n"
"  2. what if consumers send demand and there are not enough events?\n"
"\n"
"One way to implement such a broadcaster is to simply rely on the internal\n"
"buffer available in `GenStage`, dispatching events as they arrive, as explained\n"
"in the previous section:\n"
"\n"
"    defmodule Broadcaster do\n"
"      use GenStage\n"
"\n"
"      @doc \"Starts the broadcaster.\"\n"
"      def start_link() do\n"
"        GenStage.start_link(__MODULE__, :ok, name: __MODULE__)\n"
"      end\n"
"\n"
"      @doc \"Sends an event and returns only after the event is dispatched.\"\n"
"      def sync_notify(pid, event, timeout \\\\ 5000) do\n"
"        GenStage.call(__MODULE__, {:notify, event}, timeout)\n"
"      end\n"
"\n"
"      def init(:ok) do\n"
"        {:producer, :ok, dispatcher: GenStage.BroadcastDispatcher}\n"
"      end\n"
"\n"
"      def handle_call({:notify, event}, _from, state) do\n"
"        {:reply, :ok, [event], state} # Dispatch immediately\n"
"      end\n"
"\n"
"      def handle_demand(_demand, state) do\n"
"        {:noreply, [], state} # We don't care about the demand\n"
"      end\n"
"    end\n"
"\n"
"By always sending events as soon as they arrive, if there is any demand,\n"
"we will serve the existing demand, otherwise the event will be queued in\n"
"`GenStage`'s internal buffer. In case events are being queued and not being\n"
"consumed, a log message will be emitted when we exceed the `:buffer_size`\n"
"configuration.\n"
"\n"
"While the implementation above is enough to solve the constraints above,\n"
"a more robust implementation would have tighter control over the events\n"
"and demand by tracking this data locally, leaving the `GenStage` internal\n"
"buffer only for cases where consumers crash without consuming all data.\n"
"\n"
"To handle such cases, we will make the broadcaster state a tuple with\n"
"two elements: a queue and the pending demand. When events arrive and\n"
"there are no consumers, we store the event in the queue alongside the\n"
"process information that broadcasted the event. When consumers send\n"
"demand and there are not enough events, we increase the pending demand.\n"
"Once we have both the data and the demand, we acknowledge the process\n"
"that has sent the event to the broadcaster and finally broadcast the\n"
"event downstream.\n"
"\n"
"    defmodule QueueBroadcaster do\n"
"      use GenStage\n"
"\n"
"      @doc \"Starts the broadcaster.\"\n"
"      def start_link() do\n"
"        GenStage.start_link(__MODULE__, :ok, name: __MODULE__)\n"
"      end\n"
"\n"
"      @doc \"Sends an event and returns only after the event is dispatched.\"\n"
"      def sync_notify(event, timeout \\\\ 5000) do\n"
"        GenStage.call(__MODULE__, {:notify, event}, timeout)\n"
"      end\n"
"\n"
"      ## Callbacks\n"
"\n"
"      def init(:ok) do\n"
"        {:producer, {:queue.new, 0}, dispatcher: GenStage.BroadcastDispatcher}\n"
"      end\n"
"\n"
"      def handle_call({:notify, event}, from, {queue, pending_demand}) do\n"
"        queue = :queue.in({from, event}, queue)\n"
"        dispatch_events(queue, pending_demand, [])\n"
"      end\n"
"\n"
"      def handle_demand(incoming_demand, {queue, pending_demand}) do\n"
"        dispatch_events(queue, incoming_demand + pending_demand, [])\n"
"      end\n"
"\n"
"      defp dispatch_events(queue, 0, events) do\n"
"        {:noreply, Enum.reverse(events), {queue, 0}}\n"
"      end\n"
"      defp dispatch_events(queue, demand, events) do\n"
"        case :queue.out(queue) do\n"
"          {{:value, {from, event}}, queue} ->\n"
"            GenStage.reply(from, :ok)\n"
"            dispatch_events(queue, demand - 1, [event | events])\n"
"          {:empty, queue} ->\n"
"            {:noreply, Enum.reverse(events), {queue, demand}}\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"Let's also implement a consumer that automatically subscribes to the\n"
"broadcaster on `c:init/1`. The advantage of doing so on initialization\n"
"is that, if the consumer crashes while it is supervised, the subscription\n"
"is automatically reestablished when the supervisor restarts it.\n"
"\n"
"    defmodule Printer do\n"
"      use GenStage\n"
"\n"
"      @doc \"Starts the consumer.\"\n"
"      def start_link() do\n"
"        GenStage.start_link(__MODULE__, :ok)\n"
"      end\n"
"\n"
"      def init(:ok) do\n"
"        # Starts a permanent subscription to the broadcaster\n"
"        # which will automatically start requesting items.\n"
"        {:consumer, :ok, subscribe_to: [QueueBroadcaster]}\n"
"      end\n"
"\n"
"      def handle_events(events, _from, state) do\n"
"        for event <- events do\n"
"          IO.inspect {self(), event}\n"
"        end\n"
"        {:noreply, [], state}\n"
"      end\n"
"    end\n"
"\n"
"With the broadcaster in hand, now let's start the producer as well\n"
"as multiple consumers:\n"
"\n"
"    # Start the producer\n"
"    QueueBroadcaster.start_link()\n"
"\n"
"    # Start multiple consumers\n"
"    Printer.start_link()\n"
"    Printer.start_link()\n"
"    Printer.start_link()\n"
"    Printer.start_link()\n"
"\n"
"At this point, all consumers must have sent their demand which we were\n"
"not able to fulfill. Now by calling `sync_notify`, the event shall be\n"
"broadcasted to all consumers at once as we have buffered the demand in\n"
"the producer:\n"
"\n"
"    QueueBroadcaster.sync_notify(:hello_world)\n"
"\n"
"If we had called `QueueBroadcaster.sync_notify(:hello_world)` before any\n"
"consumer was available, the event would also be buffered in our own\n"
"queue and served only when demand is received.\n"
"\n"
"By having control over the demand and queue, the `Broadcaster` has\n"
"full control on how to behave when there are no consumers, when the\n"
"queue grows too large, and so forth.\n"
"\n"
"## Asynchronous work and `handle_subscribe`\n"
"\n"
"Both producer_consumer and consumer have been designed to do their\n"
"work in the `c:handle_events/3` callback. This means that, after\n"
"`c:handle_events/3` is invoked, both producer_consumer and consumer\n"
"will immediately send demand upstream and ask for more items, as\n"
"it assumes events have been fully processed by `c:handle_events/3`.\n"
"\n"
"Such default behaviour makes producer_consumer and consumer\n"
"unfeasible for doing asynchronous work. However, given `GenStage`\n"
"was designed to run with multiple consumers, it is not a problem\n"
"to perform synchronous or blocking actions inside `handle_events/3`\n"
"as you can then start multiple consumers in order to max both CPU\n"
"and IO usage as necessary.\n"
"\n"
"On the other hand, if you must perform some work asynchronously,\n"
"`GenStage` comes with an option that manually controls how demand\n"
"is sent upstream, avoiding the default behaviour where demand is\n"
"sent after `c:handle_events/3`. Such can be done by implementing\n"
"the `c:handle_subscribe/4` callback and returning `{:manual, state}`\n"
"instead of the default `{:automatic, state}`. Once the producer mode\n"
"is set to `:manual`, developers must use `GenStage.ask/3` to send\n"
"demand upstream when necessary.\n"
"\n"
"For example, the `ConsumerSupervisor` module processes events\n"
"asynchronously by starting child process and such is done by\n"
"manually sending demand to producers. The `ConsumerSupervisor`\n"
"can be used to distribute work to a limited amount of\n"
"processes, behaving similar to a pool where a new process is\n"
"started per event. The minimum amount of concurrent children per\n"
"producer is specified by `min_demand` and the `maximum` is given\n"
"by `max_demand`. See the `ConsumerSupervisor` docs for more\n"
"information.\n"
"\n"
"Setting the demand to `:manual` in `c:handle_subscribe/4` is not\n"
"only useful for asynchronous work but also for setting up other\n"
"mechanisms for back-pressure. As an example, let's implement a\n"
"consumer that is allowed to process a limited number of events\n"
"per time interval. Those are often called rate limiters:\n"
"\n"
"    defmodule RateLimiter do\n"
"      use GenStage\n"
"\n"
"      def init(_) do\n"
"        # Our state will keep all producers and their pending demand\n"
"        {:consumer, %{}}\n"
"      end\n"
"\n"
"      def handle_subscribe(:producer, opts, from, producers) do\n"
"        # We will only allow max_demand events every 5000 miliseconds\n"
"        pending = opts[:max_demand] || 1000\n"
"        interval = opts[:interval] || 5000\n"
"\n"
"        # Register the producer in the state\n"
"        producers = Map.put(producers, from, {pending, interval})\n"
"        # Ask for the pending events and schedule the next time around\n"
"        producers = ask_and_schedule(producers, from)\n"
"\n"
"        # Returns manual as we want control over the demand\n"
"        {:manual, producers}\n"
"      end\n"
"\n"
"      def handle_cancel(_, from, producers) do\n"
"        # Remove the producers from the map on unsubscribe\n"
"        {:noreply, [], Map.delete(producers, from)}\n"
"      end\n"
"\n"
"      def handle_events(events, from, producers) do\n"
"        # Bump the amount of pending events for the given producer\n"
"        producers = Map.update!(producers, from, fn {pending, interval} ->\n"
"          {pending + length(events), interval}\n"
"        end)\n"
"\n"
"        # Consume the events by printing them.\n"
"        IO.inspect(events)\n"
"\n"
"        # A producer_consumer would return the processed events here.\n"
"        {:noreply, [], producers}\n"
"      end\n"
"\n"
"      def handle_info({:ask, from}, producers) do\n"
"        # This callback is invoked by the Process.send_after/3 message below.\n"
"        {:noreply, [], ask_and_schedule(producers, from)}\n"
"      end\n"
"\n"
"      defp ask_and_schedule(producers, from) do\n"
"        case producers do\n"
"          %{^from => {pending, interval}} ->\n"
"            # Ask for any pending events\n"
"            GenStage.ask(from, pending)\n"
"            # And let's check again after interval\n"
"            Process.send_after(self(), {:ask, from}, interval)\n"
"            # Finally, reset pending events to 0\n"
"            Map.put(producers, from, {0, interval})\n"
"          %{} ->\n"
"            producers\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"With the `RateLimiter` implemented, let's subscribe it to the\n"
"producer we have implemented at the beginning of the module\n"
"documentation:\n"
"\n"
"    {:ok, a} = GenStage.start_link(A, 0)\n"
"    {:ok, b} = GenStage.start_link(RateLimiter, :ok)\n"
"\n"
"    # Ask for 10 items every 2 seconds\n"
"    GenStage.sync_subscribe(b, to: a, max_demand: 10, interval: 2000)\n"
"\n"
"Although the rate limiter above is a consumer, it could be made a\n"
"producer_consumer by changing `c:init/1` to return a `:producer_consumer`\n"
"and then forwarding the events in `c:handle_events/3`.\n"
"\n"
"## Notifications\n"
"\n"
"`GenStage` also supports the ability to send notifications to all\n"
"consumers. Those notifications are sent as regular messages outside\n"
"of the demand-driven protocol but respecting the event ordering.\n"
"See `sync_notify/3` and `async_notify/2`.\n"
"\n"
"Notifications are useful for out-of-band information, for example,\n"
"to notify consumers the producer has sent all events it had to\n"
"process or that a new batch of events is starting.\n"
"\n"
"Note the notification system should not be used for broadcasting\n"
"events, for such, consider using `GenStage.BroadcastDispatcher`.\n"
"\n"
"## Callbacks\n"
"\n"
"`GenStage` is implemented on top of a `GenServer` with two additions.\n"
"Besides exposing all of the `GenServer` callbacks, it also provides\n"
"`handle_demand/2` to be implemented by producers and `handle_events/3`\n"
"to be implemented by consumers, as shown above. Furthermore, all the\n"
"callback responses have been modified to potentially emit events.\n"
"See the callbacks documentation for more information.\n"
"\n"
"By adding `use GenStage` to your module, Elixir will automatically\n"
"define all callbacks for you except the following:\n"
"\n"
"  * `init/1` - must be implemented to choose between `:producer`, `:consumer` or `:producer_consumer`\n"
"  * `handle_demand/2` - must be implemented by `:producer` types\n"
"  * `handle_events/3` - must be implemented by `:producer_consumer` and `:consumer` types\n"
"\n"
"Although this module exposes functions similar to the ones found in\n"
"the `GenServer` API, like `call/3` and `cast/2`, developers can also\n"
"rely directly on GenServer functions such as `GenServer.multi_call/4`\n"
"and `GenServer.abcast/3` if they wish to.\n"
"\n"
"### Name Registration\n"
"\n"
"`GenStage` is bound to the same name registration rules as a `GenServer`.\n"
"Read more about it in the `GenServer` docs.\n"
"\n"
"## Message-protocol overview\n"
"\n"
"This section will describe the message-protocol implemented\n"
"by stages. By documenting these messages, we will allow\n"
"developers to provide their own stage implementations.\n"
"\n"
"### Back-pressure\n"
"\n"
"When data is sent between stages, it is done by a message\n"
"protocol that provides back-pressure. The first step is\n"
"for the consumer to subscribe to the producer. Each\n"
"subscription has a unique reference.\n"
"\n"
"Once subscribed, the consumer may ask the producer for messages\n"
"for the given subscription. The consumer may demand more items\n"
"whenever it wants to. A consumer must never receive more data\n"
"than it has asked for from any given producer stage.\n"
"\n"
"A consumer may have multiple producers, where each demand is\n"
"managed individually. A producer may have multiple consumers,\n"
"where the demand and events are managed and delivered according\n"
"to a `GenStage.Dispatcher` implementation.\n"
"\n"
"### Producer messages\n"
"\n"
"The producer is responsible for sending events to consumers\n"
"based on demand.\n"
"\n"
"  * `{:\"$gen_producer\", from :: {consumer_pid, subscription_tag}, {:subscribe, current, options}}` -\n"
"    sent by the consumer to the producer to start a new subscription.\n"
"\n"
"    Before sending, the consumer MUST monitor the producer for clean-up\n"
"    purposes in case of crashes. The `subscription_tag` is unique to\n"
"    identify the subscription. It is typically the subscriber monitoring\n"
"    reference although it may be any term.\n"
"\n"
"    Once sent, the consumer MAY immediately send demand to the producer.\n"
"    The `subscription_tag` is unique to identify the subscription.\n"
"\n"
"    The `current` field, when not nil, is a two-item tuple containing a\n"
"    subscription that must be cancelled with the given reason before the\n"
"    current one is accepted.\n"
"\n"
"    Once received, the producer MUST monitor the consumer. However, if\n"
"    the subscription reference is known, it MUST send a `:cancel` message\n"
"    to the consumer instead of monitoring and accepting the subscription.\n"
"\n"
"  * `{:\"$gen_producer\", from :: {pid, subscription_tag}, {:cancel, reason}}` -\n"
"    sent by the consumer to cancel a given subscription.\n"
"\n"
"    Once received, the producer MUST send a `:cancel` reply to the\n"
"    registered consumer (which may not necessarily be the one received\n"
"    in the tuple above). Keep in mind, however, there is no guarantee\n"
"    such messages can be delivered in case the producer crashes before.\n"
"    If the pair is unknown, the producer MUST send an appropriate cancel\n"
"    reply.\n"
"\n"
"  * `{:\"$gen_producer\", from :: {pid, subscription_tag}, {:ask, count}}` -\n"
"    sent by consumers to ask data in a given subscription.\n"
"\n"
"    Once received, the producer MUST send data up to the demand. If the\n"
"    pair is unknown, the producer MUST send an appropriate cancel reply.\n"
"\n"
"### Consumer messages\n"
"\n"
"The consumer is responsible for starting the subscription\n"
"and sending demand to producers.\n"
"\n"
"  * `{:\"$gen_consumer\", from :: {producer_pid, subscription_tag}, {:notification, msg}}` -\n"
"    notifications sent by producers.\n"
"\n"
"  * `{:\"$gen_consumer\", from :: {producer_pid, subscription_tag}, {:cancel, reason}}` -\n"
"    sent by producers to cancel a given subscription.\n"
"\n"
"    It is used as a confirmation for client cancellations OR\n"
"    whenever the producer wants to cancel some upstream demand.\n"
"\n"
"  * `{:\"$gen_consumer\", from :: {producer_pid, subscription_tag}, [event]}` -\n"
"    events sent by producers to consumers.\n"
"\n"
"    `subscription_tag` identifies the subscription. The third argument\n"
"    is a non-empty list of events. If the subscription is unknown, the\n"
"    events must be ignored and a cancel message sent to the producer.\n"
"\n"
msgstr ""
